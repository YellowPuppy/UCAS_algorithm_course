\chapter{绪论}

	所谓\uwave{算法}，是指求解给定问题的\uwave{操作步骤}---无论是人还是计算机，按步骤机械式地操作，即可求得给定问题的解。

	那么对于一个给定的问题来说，如何才能设计出求解问题的算法来呢？如果我们脱离对问题特性的认识、只是简单套用已知的算法技术的话，一般很难行得通---算法设计的关键在于深入观察待解决问题的特性；我们对问题特性认识得越多，可资使用的算法技术就越多，设计出的算法也越好。
	
	好的算法不仅是正确的，还应是高效的。因此在设计出算法之后，我们还需要对其性能进行分析，以评估算法运行所需时间和空间的数量。在评估算法性能的基础之上，我们可以比较不同算法的性能，进而改进算法的设计。
	
	 在本章里，我们首先介绍如何形式化描述算法问题；然后以旅行商问题(Traveling Salesman Problem, TSP)为例介绍算法设计的基本过程；最后以Fibonacci数的计算为例介绍算法复杂度分析的基本思想。
	
\section{问题的形式化定义}
   	
	人们在工作或者日常生活中，常常需要求解一些\uwave{实际问题}(Practical problems)，例如{\it 100 Years on the Road}\cite{100YearsOnTheRoad}这本书中记载的一个真实问题：
	
	{\kaishu 1925年，Page种子公司的推销员H. M. Cleveland从公司出发，去350个城镇推销种子。他手里有一幅地图，能够知道每个城镇的地理位置，以及两两城镇之间的距离。在出发之前，Cleveland面临的问题是：如何规划路线，使得走遍所有城镇后回到公司的总里程最短？}
%	\begin{figure}[hpt]\centering
%		\centering
%        	\includegraphics[width=2.5in]{TSP-350.png}
%		\caption{\fangsong 推销员H. M. Cleveland所面临的路线选择问题。图中黑色圆点表示城镇，共350个城镇；Cleveland使用的环游如红色线段所示。}
%    \end{figure}
		
	在使用计算技术求解上述实际问题时，公司名称、推销员姓名等信息是无关紧要的。为避免这些无关信息的干扰，我们将它们剥离出去，只保留那些对求解来说必要的信息，最终形式化描述成如下的\uwave{算法问题}(Algorithmic problem)：
	
\begin{center}
	\fbox{
		\begin{minipage}{30em}
{\bf 旅行商问题(Traveling Salesman Problem, TSP)}\\
	{\bf 输入：}  结点集合$V$，$|V|=n$，以及结点间距离矩阵$D=(d_{ij})\in \mathbf{R}^{n\times n}$，其中$d_{ij}$表示结点$i$与结点$j$之间的距离；\\
	{\bf 输出：} 最短的环游路线(Tour)，即以任一结点作出发点，经过每个结点一次且仅一次、最终返回出发点的里程最短的环游。
		\end{minipage}
	}
\end{center}
	
	算法问题的形式化描述中包含“输入”和“输出”两个部分，其中“输入”部分是指算法的“输入”，表示我们已知的信息，描述问题的所有参量及其格式；“输出”部分表示问题的“解”必须满足的条件，是算法工作的目标。
	
	算法问题的一个\uwave{特定的输入}被称作{\bf 实例}(Problem instance)。比如图\ref{TSPinstance}示出旅行商问题的3个实例，其中结点间距离标注于边上。对只包含3个结点的实例$(a)$来说，有2种环游路线且里程相同，因此求最短环游是非常简单的；而对包含4个结点的实例$(b)$来说，总共有如下6种环游路线：	
	
\begin{table}[htp]
	\centering
	\begin{tabular}{ccccccccccc}
		\hline
		环游路线 & 里程 \\
		\hline
			$a \rightarrow b \rightarrow c \rightarrow e \rightarrow a $  & 22 \\
			$a \rightarrow e \rightarrow c \rightarrow b \rightarrow a $  & 22 \\
			$a \rightarrow c \rightarrow b \rightarrow e \rightarrow a $  & 18 \\
			$a \rightarrow e \rightarrow b \rightarrow c \rightarrow a $  & 18 \\
			$a \rightarrow b \rightarrow e \rightarrow c \rightarrow a $  & 18 \\
			$a \rightarrow c \rightarrow e \rightarrow b \rightarrow a $  & 18 \\
		\hline
	\end{tabular}
	\caption{\fangsong TSP问题实例$(b)$的所有环游路线及其总里程}
\end{table}
	从表中可以看出，最短环游的总里程是18；$a \rightarrow b \rightarrow c \rightarrow d \rightarrow a $是里程最短的环游之一。我们的目的是对于任意给定的TSP实例，能够计算出最短环游。
	
	值得指出的是，在问题的形式化过程中，我们通常还要进行抽象。就TSP问题来说，我们将“城市”抽象表示成“结点”。这样处理的好处是：抽象出的算法问题不仅可以表示Cleveland所面临的路线规划问题，还可以表示与之相似的一大类问题，从而具有推广的可能性。
	
	当一个算法能够应用于问题的任何实例，并始终能够获得符合问题“输出部分”规定的解时，我们才称\uwave{此算法解答了这个问题}。
	
	
\begin{figure}[htp]
	\centering
	\begin{tikzpicture}[scale=1, auto,swap]

%n=3
   \def\dx{-10.6}
    \foreach \pos/ \name in {{(0 + \dx,0)/a}, {(1.25 + \dx, 2.0)/c}, {(2.5 + \dx,0)/b}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};

   %Connect vertices with edges and draw weights
    \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, b/c/{4} }
        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
     \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, b/c/{4} }
        \path[undirectededge, red] (\source) -- node[weight] {} (\dest);
 \node at (1.25+\dx, -0.6) {$(a)$}; 
 
 
 
 \def\dx{-5.2};
 
     \foreach \pos/ \name in {{(-2 + \dx ,0)/a},{(2+ \dx ,0)/b}, {(-1+ \dx ,1.6)/e}, {(1+ \dx ,1.6)/c}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/e/{8}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \foreach \source/ \dest/\weight in {a/b/,   b/c/}
        \path[undirectededge, black] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {a/b/,   e/c/}
        \path[undirectededge, black] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {b/e/,  a/c/, c/e/, a/b/}
        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);

 \node at (0+\dx, -0.6) {$(b)$}; 

 
 \def\dx{0};
 
     \foreach \pos/ \name in {{(-2 + \dx ,0)/a},{(2+ \dx ,0)/b}, {(-1+ \dx ,1.6)/e}, {(1+ \dx ,1.6)/c}, {(0+ \dx ,3.2)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    % Connect vertices with edges and draw weights
     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \draw[thick] (a)   to [out=140, in=180] node[above] {2} (d);   
        \draw[thick] (b)   to [out=40, in=0] node[above] {6} (d);   

    \foreach \source/ \dest/\weight in {b/e/,   b/c/,   d/e/, a/c/}
        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);

   \draw[thick] (a)   to [out=140, in=180] node[above] {2} (d);   
   \draw[thick, red] (a)   to [out=140, in=180] node[above] { } (d);  
   
 \node at (0+\dx, -0.6) {$(c)$}; 
%%n=4 
%    \foreach \pos/ \name in {{(0,0)/1},{(0,2)/2}, {(2,2)/3}, {(2,0)/4}} 
%        \node[middlevertex,fill=blue!20] (\name) at \pos{$\name$};
%
%     
%    % Connect vertices with edges and draw weights
%    \foreach \source/ \dest/\weight in {2/1/{1},   1/4/{3}, 3/2/{5}, 4/3/{3}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%    \foreach \source/ \dest/\weight in  {3/1/{}, 4/2/{}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%     
%     \node at (0.6, 0.3) {\small $8$};   
%     \node at (0.6, 1.7) {\small $7$};   
%
 
        
     \end{tikzpicture}
     \caption{\fangsong 旅行商问题的3个实例：$n=3, 4, 5$，其中结点对之间的距离标注于相应的边上。最短环游路线使用红色示出。}
     \label{TSPinstance}
\end{figure}
	
	
	



\section{算法设计的基本过程}
	那么当给定一个算法问题时，怎样才能设计出求解此问题的算法呢？
	
	在介绍算法设计的基本过程之前，我们不妨先来读一下V. Vazirani说过的具有指导意义的一段话\cite{VaziraniBook}：

{\kaishu  无论是算法设计还是算法的讲解，其背后的哲学都和米开朗基罗做雕塑的过程非常相似：在创作一件艺术品时，米开朗基罗的绝大部分的努力和时间，都花在寻找一块“有内涵”的石头、并琢磨这块石头内蕴的天然结构上。一旦看清楚了这块石头所内蕴的天然结构之后，斧凿之功就是简单的事情了。
%Our philosophy on the design and exposition of algorithms is nicely illustrated by the following analogy with an aspect of Michelangelos's art:  A major part of his effort involved looking for interesting pieces of stone in the quarry and staring at them for long hours \textcolor{red}{\bf to determine the form they naturally wanted to take}. The chisel work exposed, in a minimal manner, this form. 

  之所以说算法设计过程与米开朗基罗的创作过程很相似，是因为我们在设计算法时，绝大部分努力与时间都花在琢磨问题内蕴的组合结构上。一旦琢磨清楚问题的内在结构之后，设计合适的算法就是简单的事情了---依据问题的结构，设计求解问题的操作步骤，并尽量保持操作步骤的精炼与简单。
%By analogy, we would like to start with a clean, simply stated problem. Most of the algorithm design effort actually goes into \textcolor{red}{\bf understanding the algorithmically relevant combinatorial structure of the problem}.  The algorithm exploits this structure in a minimal manner.....  with emphasis on stating the structure offered by the problems, and keeping the algorithms minimal.  
}

         或许反过来想，能够更好地理解这段话：对于一个给定的问题，如果我们脱离了对问题特性的认识，只是简单地套用已知的算法技术，一般很难行得通---算法设计的关键在于深入观察待解决问题的特性；我们对问题特性认识得越多，可资使用的算法技术就越多，设计出的算法也就可能更好。

\subsection{观察问题内在结构的途径}
	要想观察问题的内在结构，我们可以尝试做如下的思考：
	\begin{itemize}
		\item {\bf 观察一、问题的可分解性：}问题的\uwave{最简单实例}是什么？复杂的实例能否\uwave{分解}成简单的实例？
		\item {\bf 观察二、可行解的形式以及解之间的变换关系：}问题的\uwave{可行解的形式}是什么？我们能否对一个可行解施加小幅扰动，将之\uwave{变换成另一个可行解}？
		\item {\bf 观察三、类似的问题：}和给定问题\uwave{类似的问题}有哪些？解决类似问题的算法能否直接应用于解决当前的问题？如果不能，那又是什么因素造成了妨碍？能否想办法消除这些妨碍因素？
	\end{itemize}
	
	依据对问题内在结构的观察，我们采用相应的策略设计算法：
	
	{\bf “分而治之”策略：}如果我们观察到问题具有\uwave{可归约性}，即问题的复杂实例可以分解成一些简单实例，而且反过来，简单实例的解可以用来组成原问题的解，那我们就可以尝试“基于归约原理的算法设计”\cite{ManberBook}。这一类算法的典型代表是“分而治之”(Divide and Conquer)，即先把问题的复杂实例分解成一些简单实例，然后通过递归调用求解简单实例，最后用简单实例的解“组合”出复杂实例的解。这些简单实例具有和原始的复杂实例相同的形式，只是规模更小一些，也常常称作\uwave{子实例}（Sub-instance）；求解子实例则称为对应于原始问题的\uwave{子问题}（Sub-problem）。
	
	在此基础上，我们做进一步的观察：如果待求解的问题是一个优化问题，而且我们能够观察到\uwave{最优子结构性质}(Optimal substructure)，那么我们可以尝试设计\uwave{动态规划}(Dynamic programming)求解算法。所谓最优子结构性质，是指原始复杂实例的最优解能够由子实例的最优解组合而成。
	
	再进一步地观察问题结构：如果待求解的问题不仅具有最优子结构性质，还具有\uwave{贪心选择性质}(Greedy selection)，那我们可以尝试设计贪心算法求解问题。所谓贪心选择性质，是指“\uwave{局部最优决策}”(Locally optimal decision)，可以直观地理解为做决策时的“短视”策略，即：问题的解可以一步一步地逐渐构造而成；在构造的每一步，无需考虑尚未求解的子问题，只依据已经构造出的部分解即可做出最优或者近乎最优的选择。在这一点上，贪心算法与动态规划算法显著不同：动态规划算法中需要考虑子问题的解、通过回溯才能确定出最优解。
	
       {\bf “逐步改进”策略：} 如上所述，能够应用“分而治之”策略进行算法设计的前提是我们观察到问题具有可分解性。但是对于不容易分解的问题（或者虽然能够分解但是我们并不去分解），又该如何设计求解算法呢？
       
    在这种情形之下，我们可以尝试\uwave{“逐步改进”}(Improvement strategy)策略，即首先构造出给定问题的一个粗糙的\uwave{完整可行解}(Complete solution)，然后逐步修正完整解以改进其质量，直到获得满意的解。值得指出的是，由于不进行问题的分解，也就不存在子问题以及子问题的解这些概念，我们只有问题的完整可行解可资使用，因此也只能逐步修正完整可行解以改进其质量。 所谓的改进完整解，是指将一个完整解进行小的扰动，变成另一个完整解；其中所依赖的是对\uwave{完整解之间变换关系}的观察。

	逐步改进类的典型算法有线性规划(Linear programming)、非线性规划(Non-linear programming)、计算最大流的网络流算法(Network flow)、局部搜索(Local search)、模拟退火(Simulated annealing)等。最大流问题为逐步改进策略提供了一个很好的注解：最大流问题不容易分解成子问题；因此到目前为止，尚未设计出求解最大流问题的分而治之类高效算法，目前最高效的算法都是采用逐步改进的策略\cite{PapadimitriouBook1982}。

	{\bf “智能枚举”策略：}除了观察问题是否能分解之外，我们还可以观察问题的\uwave{可行解的形式}。假如问题的可行解可以表示成如下形式：
		\begin{center}
	$X=[x_{1}, x_{2}, \cdots, x_{n}]$, $x_{i} = 0/1$
		\end{center}
	则我们可以尝试采用“枚举”策略(Enumeration)设计求解算法，即产生出所有的可行解，进而从中找出符合要求的解。一般来说，可行解的数目较多，导致简单的枚举策略求解时间过长。为加快求解过程，通常采用“智能枚举”策略(Intelligent enumeration)，即对枚举树进行剪枝，忽略一些低质量的可行解\cite{PapadimitriouBook}。
	
	枚举类的典型算法有回溯法(Backtracking)、分支限界算法(Branch and bound)等。值得指出的是，贪心算法可以看做枚举策略的一个特例：贪心算法在构造解的每一步都依据贪心规则作出选择，最终形成枚举树中的一条路径，因此可以看做是最极端的一种剪枝。
	
	{\bf 针对“难”的问题的算法设计策略：}	
有些问题迄今为止尚未找到快速的求解算法，从而被称作“难”的问题。难度是问题的本质属性；我们可以通过观察问题之间的\uwave{归约关系}来证明某个问题比另一个问题难度更高。证明了给定的问题是“难”的问题，就意味着只有放松要求才能设计出高效的算法：比如我们可以不再要求算法一定要求得最优解、只要求获得“足够好”的解；我们也可以不再要求算法的每一步操作都是确定性的，允许算法中存在随机化行为，仅要求算法输出错误结果的概率很小、或者期望运行时间很短；我们还可以不再要求算法对“最坏的问题实例”能够很快运行，仅仅要求算法在大部分现实情况下运行很快。值得指出的是：在放松了要求之后，我们依然要先观察问题结构，继而基于问题结构设计高效的求解算法\cite{HardBook}。

	
	下面我们以旅行商问题为例，说明如何对问题进行观察，以及在此观察基础上如何应用上述三类策略进行算法设计。
	
\subsection{“分而治之”算法设计过程简介}
	在设计求解TSP问题的算法之前，我们首先\uwave{从最简单的实例入手}，画一些简单的实例以观察规律。如图\ref{TSPinstance}$(a)$所示，最简单的TSP实例是只有3个结点的情形，其最短环游非常容易计算。
		
	接下来我们考察\uwave{复杂的实例能否分解成简单实例}、以及能否\uwave{使用简单实例的解组合出复杂实例的解}。然而不幸的是，虽然一个复杂的TSP实例能够比较容易地分解成简单实例，但是用简单实例的解组合出复杂实例的解却不太容易。如图\ref{TSPinstance}所示，对于包含5个结点$a, b, c, d, e$的TSP实例$(c)$来说，我们去除结点$d$后，即获得一个只有4个结点$a, b, c,   e$的TSP实例$(b)$；但是由于要求解是一个环游，我们很难找到一个通用的构造规则，能够将实例$(b)$的解（由红色边示出的最短环游）转换成实例$(c)$的解（由红色边示出的最短环游)。
	
\subsubsection*{转换目标：求解一个辅助问题}
	上述困难导致我们难以设计出直接求解TSP问题的分而治之算法。因此我们转换一下目标，先求解一个\uwave{辅助问题}：计算从结点$s$出发、经过结点集合$S$中的结点一次且仅一次、最终到达目的结点$e$的里程\uwave{最短路径}，记为$M(s, S, e)$。
	
	研究这个辅助问题$M(s, S, e)$有两点好处：$(i)$ 可以基于辅助问题的解构造出TSP问题的解；$(ii)$ 容易设计一个分而治之算法计算$M(s, S, e)$。我们首先来看第一点。
	 	考察图\ref{TSPinstance}$(b)$所示的TSP实例：假设我们从结点$a$出发，则环游路线最终返回$a$时有三种情况，分别是从$b$返回$a$、从$c$返回$a$，以及从$d$返回$a$；因此我们可以将最短环游路线的里程表示如下：
\[ 
\begin{array}{lll}
\min\{&d_{ba} + M(a, \{c, d\}, b), \\ 
              & d_{ca} + M(a, \{b, d\}, c ), \\ 
              & d_{da} + M(a, \{b, c\}, d ) \}
\end{array}            
\]
上述观察可以推广到任意的TSP实例：如果对任意的$s\in V$, $e\in V$, $S\subseteq V$，都能够计算出$M(s, S, e)$，则可以求解原始的TSP问题。此算法称为{\sc Bellman-Held-Karp}算法\cite{HeldKarp1961,Bellman1962}，伪代码如下：
\begin{algorithm}[H]
\caption{{\sc Bellman-Held-Karp} algorithm for TSP}\label{TSPHeldKarpAlgo}
{\bf function} {\sc Bellman-Held-Karp}{$(V, D)$} 
\begin{algorithmic}[1]
	\REQUIRE{$|V|\geq 3$}
	\IF{$|V| =3$}
		\STATE{Let's represent the nodes in $V$ as $V=\{a, b, c\}$;}
		\RETURN{$d_{ab} + d_{bc} + d_{ca}$;}
	\ELSE
		\RETURN{$\min_{e \in V, e \neq s}\{{\sc M}(s, V - \{e\}, e) + d_{es}\}$;} %\Comment{$s$ is an arbitrary node in $V$;} 
	\ENDIF
\end{algorithmic}
\end{algorithm}

其中$s\in V$是任意一个结点。
	
		
	接下来我们看第二点，如何计算$M(s, S, e)$。我们依然先从最简单的实例$|S|=1$入手。如图\ref{MSE}$(a)$所示，当$|S|=\{c\}$时，$M(a, \{c\}, b)$可以非常容易地计算出来：
	\begin{center}
		$M(a, \{c\}, b) = d_{ac} + d_{cb}$
	\end{center}
	更重要的是，对于$|S|\geq 2$的复杂实例，我们可以将其归约成简单实例。如图\ref{MSE}$(b)$和$(c)$所示，我们可以如下计算$M(a, \{c, e\}, b)$：
	\begin{center}
		$M(a, \{c, e\}, d) = \min\{ d_{cb} + M(a, \{e\}, c), d_{eb} + M(a, \{ c\}, e) \} $
	\end{center}
	因此我们可以设计如下的分而治之算法计算$M(s, S, e)$：\\
\begin{algorithm}[H]
\caption{Algorithm to calculate {\sc M}$(s, S, e)$}\label{TSPMSEAlgo}
{{\bf function} {\sc M}$(s, S, e)$}
\begin{algorithmic}[1]
\IF{$|S| = 1$}
	\STATE{Let's represent $S$ as $S=\{v\}$;}
	\STATE {\sc M}$(s, S, e) = d_{sv} + d_{ve}$; 
	\RETURN{{\sc M}$(s, S, e)$}; 
\ENDIF
\RETURN{$\min_{i \in S,\ i \neq e}${\sc M}$(s, S - \{i\}, i) + d_{ei}$}; 
\end{algorithmic}
\end{algorithm}
	值得注意的是，对TSP问题来说，由于解必须是环游这一约束，使得我们难以基于子问题的解构造出原问题的解。与之相反，$M(s, S, e)$的计算避开了这个困难：引入不同于出发点$s$的目的结点$e$之后，解不再是一个环游，而只是一条路径，从而使得我们能够基于子问题的解构造出原问题的解。这也是能够应用分而治之技术计算$M(s, S, e)$的原因之所在。

\begin{figure}[htp]
	\centering
	\begin{tikzpicture}[scale=1, auto,swap]

%n=3
   \def\dx{-10.6}
    \foreach \pos/ \name in {{(0 + \dx,0)/a}, {(1.25 + \dx, 2.0)/c}, {(2.5 + \dx,0)/b}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};

   %Connect vertices with edges and draw weights
    \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, b/c/{4} }
        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
 
     \foreach \source/ \dest/\weight in {  c/a/{4}, b/c/{4} }
        \path[undirectededge, red] (\source) -- node[weight] { } (\dest);


 \node at (1.25+\dx, -0.6) {$(a)$}; 
 
 
 %n=4
 \def\dx{-5.2};
 
     \foreach \pos/ \name in {{(-2 + \dx ,0)/a},{(2+ \dx ,0)/b}, {(-1+ \dx ,1.6)/e}, {(1+ \dx ,1.6)/c}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/e/{8}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \foreach \source/ \dest/\weight in {a/b/,   b/c/}
        \path[undirectededge, black] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {a/b/,   e/c/}
        \path[undirectededge, black] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {b/c/,  e/c/,   a/e/}
        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);

 \node at (0+\dx, -0.6) {$(b)$}; 

 %n=4 
 \def\dx{0};
 
     \foreach \pos/ \name in {{(-2 + \dx ,0)/a},{(2+ \dx ,0)/b}, {(-1+ \dx ,1.6)/e}, {(1+ \dx ,1.6)/c}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/e/{8}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \foreach \source/ \dest/\weight in {a/b/,   b/c/}
        \path[undirectededge, black] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {a/b/,   e/c/}
        \path[undirectededge, black] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {b/e/,  a/c/,   c/e/}
        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);

 \node at (0+\dx, -0.6) {$(c)$}; 
%%n=4 
%    \foreach \pos/ \name in {{(0,0)/1},{(0,2)/2}, {(2,2)/3}, {(2,0)/4}} 
%        \node[middlevertex,fill=blue!20] (\name) at \pos{$\name$};
%
%     
%    % Connect vertices with edges and draw weights
%    \foreach \source/ \dest/\weight in {2/1/{1},   1/4/{3}, 3/2/{5}, 4/3/{3}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%    \foreach \source/ \dest/\weight in  {3/1/{}, 4/2/{}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%     
%     \node at (0.6, 0.3) {\small $8$};   
%     \node at (0.6, 1.7) {\small $7$};   
%
 
        
     \end{tikzpicture}
%     \caption{\fangsong 旅行商问题的3个实例：$n=3, 4, 5$，其中结点对之间的距离标注于相应的边上。最短环游路线分别使用红色和蓝色示出。}
%     \label{TSPinstance}
%\end{figure}
%	
%
%
%
%\begin{figure}\centering[hpt]
%	\centering
%	\begin{tikzpicture}[scale=1, auto,swap]
%
%
%%    \foreach \pos/ \name in {{(0,0)/1},{(0,1.5)/2}, {(1.8,1.5)/3}} 
%%        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%%
%%    % Connect vertices with edges and draw weights
%%    \foreach \source/ \dest/\weight in {2/1/{1},   3/2/{5}}
%%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%%    \foreach \source/ \dest/\weight in  {3/1/{8}}
%%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%%
%%    \foreach \source/ \dest/\weight in {2/1/{},   3/2/{}}
%%        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);
%        
%   \def\dx{-4};
%   
%    \foreach \pos/ \name in {{(0+\dx,0)/a},{(1.8+\dx,0)/c}, {(0.9+\dx,1.5)/b}} 
%        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%
%    % Connect vertices with edges and draw weights
%    \foreach \source/ \dest/\weight in {a/b/{1},   a/c/{5}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%    \foreach \source/ \dest/\weight in  {b/c/{8}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%
%    \foreach \source/ \dest/\weight in {a/b/{},   b/c/{}}
%        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);
%        
%        
%        \node[] at (-3, -0.6) {\small $(a)$}; 
%        \node[] at (1, -0.6) {\small $(b)$}; 
%        \node[] at (5, -0.6) {\small $(c)$}; 
%                
%
%
%
%%|S|=2
%    \foreach \pos/ \name in {{(0,0)/a},{(0,1.8)/b}, {(1.8,1.8)/c}, {(1.8,0)/d}} 
%        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%
%     
%    % Connect vertices with edges and draw weights
%    \foreach \source/ \dest/\weight in {b/a/{1},   a/d/{3}, c/b/{5}, d/c/{3}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%    \foreach \source/ \dest/\weight in  {c/a/{}, d/b/{}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%     
%     \node at (0.6, 0.3) {\small $8$};   
%     \node at (0.6, 1.5) {\small $7$};   
%        
%%red 	
%    \foreach \source/ \dest/\weight in  {a/b/{}, b/c/{}, d/c/{}}
%        \path[undirectededge,red] (\source) -- node[weight] {$\weight$} (\dest);
%
%
%
%
%    \foreach \pos/ \name in {{(4,0)/a},{(4,1.8)/b}, {(5.8,1.8)/c}, {(5.8,0)/d}} 
%        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%
%     
%    % Connect vertices with edges and draw weights
%    \foreach \source/ \dest/\weight in {b/a/{1},   a/d/{3}, c/b/{5}, d/c/{3}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%    \foreach \source/ \dest/\weight in  {c/a/{}, d/b/{}}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%     
%     \node at (4+0.6, 0.3) {\small $8$};   
%     \node at (4+0.6, 1.5) {\small $7$};   
%        
%%red 	
%    \foreach \source/ \dest/\weight in  {a/c/{}, b/c/{}, d/b/{}}
%        \path[undirectededge,red] (\source) -- node[weight] {$\weight$} (\dest);
%
%        
%	\end{tikzpicture}

	\caption{\fangsong $M(s, S, e)$的计算过程。{\bf $(a)$}. 当$S$只包含一个结点$c$时，$M(a, \{c\}, b) = d_{ac} + d_{cb}$。{\bf $(b)$, $(c)$}. 当$S$包含2个结点$c, e$时，$M(a, \{c, e\}, b) = \min\{ d_{cd} + M(a, \{e\}, c), d_{eb} + M(a, \{ c\}, e)\}$。}
		\label{MSE}
\end{figure}

\subsection{“逐步改进”算法设计过程简介}
	与“分而治之”算法的思想截然不同，“逐步改进”策略不考虑如何将原始问题分解成子问题、以及如何将子问题的解组合成原问题的解，而是直接考虑\uwave{原问题的完整可行解}。以图\ref{TSPinstance}$(c)$中所示的TSP实例为例，$a\rightarrow b  \rightarrow c \rightarrow d \rightarrow e \rightarrow a$是一条环游路线，是这个实例的一个完整可行解。当然，这个完整可行解的总里程是25，“质量”不太高，需要想办法进行改进。

   “逐步改进”算法的\uwave{基本过程}是：从问题的一个粗糙的、质量不太高的完整可行解开始，不断进行改进，直至获得满意的解为止；在算法运行过程中，考虑的都是完整可行解。求解TSP问题的“逐步改进”算法的一般性框架可以描述如下：
   
\begin{algorithm}[H]
\caption{Improvement algorithm for TSP}\label{TSPImprovementAlgo}
{\bf function} {\sc GenericImprovement}$(V, D)$
\begin{algorithmic}[1]
\STATE Let $S$ be an initial tour; 
\WHILE{{\tt TRUE} }
	\STATE Select a new tour $S'$ from the \textcolor{red}{\bf neighbourhood} of $S$; 
	\IF{$s'$ is shorter than $S$ }  
		\STATE $S = S'$; 
	\ENDIF
	\IF{{\sc Stopping}($S$)}
		\RETURN{$S$}; 
	\ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

上述的一般性框架中，有3处需要做进一步的明确规定：
\begin{enumerate}[(1)]
\item 
 \uwave{初始可行解的选择}（第1行）：可以任意选择一个初始可行解，也可以采用启发式规则等选择高质量的初始点以加快改进过程。为简单起见，此处我们采用选择任意初始解的策略。

\item  \uwave{可行解的改进方法}（第3行）：将一个低质量的可行解进行修改，变成另一个质量更高的可行解，是“逐步改进”算法的核心。这依赖于我们对\uwave{可行解之间的变换关系}的定义，即需要规定对一个解$S$做一些小的“扰动”（Perturbation）之后，可以变换成哪些解$S'$；所有可能的变换形成的解$S'$构成$S$的“邻域”(Neighborhood)。

      此处我们采用{\tt 2-Opt}扰动，即从环游$S$中选择不相交的2条边，交换其端点，产生一个新的环游$S'$；扰动前后的环游只在两条边上存在差异。以图\ref{TSP2Opt}所示的环游$S=a\rightarrow b \rightarrow c \rightarrow d \rightarrow a$为例，我们首先选择顶点不相交的两条边$(a, d)$和$(b, c)$，然后删除这两条边，并将4个端点交叉连接生成两条新的边(以红色示出)，即$a$连接$c$、$b$连接$d$，最终获得新的环游$S'=a\rightarrow b \rightarrow d \rightarrow c \rightarrow a$。其他常用的解变换规则包括{\tt 3-Opt}, Lin-Kernighan启发式规则等\cite{LinKernighan1973}。

\item \uwave{算法的终止条件}（第7行）：由于算法是对可行解迭代进行改进，因此需要规定解满足何种条件时算法终止。常用的终止条件包括：若对当前可行解无法做进一步改进，则算法终止；或者迭代次数超过预先定义的阈值时算法结束。此处我们采用第一种方案。
\end{enumerate}

    图~\ref{TSPImprovementExample}展示“逐步改进”算法运行的一个例子：算法运行的初始可行解是环游$S=a\rightarrow b \rightarrow c \rightarrow d \rightarrow a$(蓝色边组成的路径)，总里程为25；第一次迭代情况见图~\ref{TSPImprovementExample}$(a)$：选择两条边$(a, e)$和$(c, d)$执行{\tt 2-Opt}操作，生成新的边$(a, d)$和$(c, e)$（红色边），并相应地生成新的环游$S=a\rightarrow b \rightarrow c \rightarrow e \rightarrow d \rightarrow a$，总里程降低为23；第二次迭代情况见图~\ref{TSPImprovementExample}$(b)$：选择两条边$(a, b)$和$(c, e)$执行{\tt 2-Opt}操作，生成新的边$(a, c)$和$(b, e)$（红色边），并相应地生成新的环游$S=a\rightarrow b \rightarrow e \rightarrow c \rightarrow d \rightarrow a$，总里程进一步降低至为19（见图~\ref{TSPImprovementExample}$(c)$）。此时无论选择哪两条边进行{\tt 2-Opt}操作，都不能产生更短的环游，因此算法结束，返回环游$S=a\rightarrow b \rightarrow e \rightarrow c \rightarrow d \rightarrow a$作为最终结果。

      需要指出的是：虽然在这个实例上“逐步改进”算法求得了最优解，但是在一般情况下，“逐步改进”算法不能保证获得最优解。
   
\begin{figure}[htp]\centering
	\centering
	\begin{tikzpicture}[scale=1, auto,swap]

%right
    \foreach \pos/ \name in {{(4,0)/a},{(4,2)/b}, {(6,2)/c}, {(6,0)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
    
    % Connect vertices with edges and draw weights
    \foreach \source/ \dest/\weight in {b/a/{1},   c/d/{3} }
        \path[undirectededge] (\source) -- node[weight] { } (\dest);
    \foreach \source/ \dest/\weight in  {c/a/{8}, d/b/{7}}
        \path[undirectededge, red] (\source) -- node[weight] { } (\dest);
 

 	\node[] at (5, -0.5) {$S'$}; 
   


   \draw[->, blue, line width=2pt] (2.6, 1) -- (3.4, 1);
 
%left
    \foreach \pos/ \name in {{(0,0)/a},{(0,2)/b}, {(2,2)/c}, {(2,0)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};

    
    % Connect vertices with edges and draw weights
    \foreach \source/ \dest/\weight in {b/a/{1},   c/d/{3} }
        \path[undirectededge] (\source) -- node[weight] { } (\dest);
    \foreach \source/ \dest/\weight in  {d/a/{8}, c/b/{7}}
        \path[undirectededge, blue] (\source) -- node[weight] { } (\dest);
        
  	\node[] at (1, -0.5) {$S$}; 

        \end{tikzpicture}
	\caption{\fangsong TSP问题中解变换的{\tt 2-Opt}规则。采用此规则，将环游$S=a\rightarrow b \rightarrow c \rightarrow d \rightarrow a$变换成新的环游$S'=a\rightarrow b \rightarrow d \rightarrow c \rightarrow a$。}
	\label{TSP2Opt}
\end{figure}

\begin{figure}[htp]\centering
	\begin{tikzpicture}[scale=0.9, auto,swap]

%Step 1
\def\dx{0};
\def\dy{0};

     \foreach \pos/ \name in {{(-2 + \dx ,0+\dy)/a},{(2+ \dx ,0+\dy)/b}, {(-1+ \dx ,1.6+\dy)/e}, {(1+ \dx ,1.6+\dy)/c}, {(0+ \dx ,3.2+\dy)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    % Connect vertices with edges and draw weights
     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \draw[thick] (a)   to [out=140, in=180] node[above] {2} (d);   
        \draw[thick] (b)   to [out=40, in=0] node[above] {6} (d);   
        
    \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in { e/c/}
        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);
 
         
    \foreach \source/ \dest/\weight in {   d/c/,   e/a/}
        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);


   \draw[thick, red] (a)   to [out=140, in=180] (d);   
 
%  \draw[->, line width=3pt, green] (2.7, 1.5) -- (3.3, 1.5); 
 	\node at (0+\dx, -0.7+\dy) {$(a)$}; 
 
%Step 2 
 \def\dx{5.5};
  \def\dy{0};
  
     \foreach \pos/ \name in {{(-2 + \dx ,0+\dy)/a},{(2+ \dx ,0+\dy)/b}, {(-1+ \dx ,1.6+\dy)/e}, {(1+ \dx ,1.6+\dy)/c}, {(0+ \dx ,3.2+\dy)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    % Connect vertices with edges and draw weights
     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \draw[thick] (a)   to [out=140, in=180] node[above] {2} (d);   
        \draw[thick] (b)   to [out=40, in=0] node[above] {6} (d);   

    \foreach \source/ \dest/\weight in {a/b/,   b/c/,   d/e/, e/c/}
        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);

    \foreach \source/ \dest/\weight in {a/b/,   e/c/}
        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);


  \draw[thick,blue] (a)   to [out=140, in=180] node[above] {2} (d);   


    \foreach \source/ \dest/\weight in {b/e/,  a/c/}
        \path[undirectededge, red] (\source) -- node[weight] {$\weight$} (\dest);

% \draw[->, line width=3pt, green] (2.7 + \dx, 1.5 + \dy) -- (3.3 + \dx, 1.5 + \dy); 
  	\node at (0+\dx, -0.7+\dy) {$(b)$}; 

 
%Step 3
 \def\dx{11};
  \def\dy{0};
  
     \foreach \pos/ \name in {{(-2 + \dx ,0+\dy)/a},{(2+ \dx ,0+\dy)/b}, {(-1+ \dx ,1.6+\dy)/e}, {(1+ \dx ,1.6+\dy)/c}, {(0+ \dx ,3.2+\dy)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     

    % Connect vertices with edges and draw weights
     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
    \foreach \source/ \dest/\weight in {a/b/{3},   a/c/{4}, e/a/{7}, b/c/{4}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \draw[thick] (a)   to [out=140, in=180] node[above] {2} (d);   
        \draw[thick] (b)   to [out=40, in=0] node[above] {6} (d);   

    \foreach \source/ \dest/\weight in {b/e/,   b/c/,   d/e/, a/c/}
        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);

   \draw[thick, blue] (a)   to [out=140, in=180] node[above] {2} (d);   

 	\node at (0+\dx, -0.7+\dy) {$(c)$}; 


\end{tikzpicture}
	\caption{\fangsong “逐步改进”算法求解旅行商问题的运行示例。$(a)$和$(b)$显示算法执行的两次迭代改进过程，$(c)$显示求得的最终解。在算法运行过程中，完整可行解用蓝色边示出，{\tt 2-Opt}操作产生的新边用红色示出。}
	\label{TSPImprovementExample}
\end{figure}





\subsection{“智能枚举”算法设计过程简介}
%\subsubsection*{观察可行解的形式}
  除了观察问题的可分解性之外，我们还可以观察\uwave{可行解的形式}。首先看一个具体例子：图~\ref{TSPSolutionForm}所示的实例中共有10条边，蓝色标识的环游只包括其中5条边，可以表示为：
\[
	X=1001100101  
\]
其中$x_{i} = 1$表示环游经过边$e_{i}$，$x_{i} = 0$表示环游不经过边$e_{i}$。

   我们可以将上述观察推广到任意的TSP实例，即将其完整可行解表示成一个向量$X=x_{1}x_{2}\cdots x_m$, 其中$x_{i}=0/1$ ($1\leq i \leq m$)，共有$n$个$x_{i}=1$。此处的$n$表示结点数，$m$表示所有边的总数。
   \begin{figure}[htp]\centering
	\centering
	\begin{tikzpicture}[scale=0.9, auto,swap]

    \foreach \pos/ \name in {{(-2,0)/a},{(2,0)/b}, {(-1,1.6)/e}, {(1,1.6)/c}, {(0,3.2)/d}} 
        \node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
     
    % Connect vertices with edges and draw weights
     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
    \foreach \source/ \dest/\weight in {a/b/{e_{1}{:}\  3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/{e_{8}{:}\  5}, c/e/{e_{9}{:}\  8}, d/e/{e_{10}{:}\  6}}
        \path[undirectededge] (\source) -- node[weight] {\small $\weight$} (\dest);
         
    \draw[thick] (a)   to [out=140, in=180] node[left] {\small $e_{3}{:}\  2$} (d);   
        \draw[thick] (b)   to [out=40, in=0] node[right] {\small $e_{6}{:}\  6$} (d);   
        
       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);

	\node[] at (-0.9, 0.3) {\small $e_{2}{:}\  4$}; 
	\node[] at (0.9, 0.3) {\small $e_{7}{:}\  3$}; 

	%	$e_1=<a, b>, e_2=<a, c>, e_3 = <a, d>, e_4=<b, c>, e_5=<b, d>, e_6 = <b, e>, e_7=<c, d>, e_8=<c, e>, e_9=<d,e>$.  
        
%           \node at (4,3) {\small $e_{1}{:}\  <a, b>$}; 
%           \node at (4,2.6) {\small $e_{2}{:}\  <a, c>$};        
%           \node at (4,2.2) {\small $e_{3}{:}\  <a, d>$};        
%           \node at (4,1.8) {\small $e_{4}{:}\  <b, c>$};        
%           \node at (4,1.4) {\small $e_{5}{:}\  <b, d>$};        
%           \node at (4,1.0) {\small $e_{6}{:}\  <b, e>$};        
%           \node at (4,0.6) {\small $e_{7}{:}\  <c, d>$};        
%           \node at (4,0.2) {\small $e_{8}{:}\  <c, e>$};        
%            \node at (4,-0.2) {\small $e_{9}{:}\  <d, e>$};        
            
\end{tikzpicture} 
\caption{\fangsong 旅行商问题可行解的向量表示。首先对所有边进行标号，蓝色标识的环游包含5条边，可以表示为$X=1001100101$，其中$x_{i} = 1$表示环游经过边$e_{i}$，$x_{i} = 0$表示环游不经过边$e_{i}$。}
\label{TSPSolutionForm}
\end{figure}

\subsubsection*{用于枚举可行解的“部分解树”} 
   对于具有向量形式的可行解，我们可以将所有的可行解组织成一棵树，称为“部分解树”(Partial Solution Tree \cite{PapadimitriouBook,ZhuBook})。如图~\ref{TSPPartialSolutionTree}所示，部分解树中的每个结点表示一个解：\uwave{内部结点}表示部分解，即只有一些分量$x_{i}$的取值已确定；\uwave{叶子结点}表示完整解，即所有分量$x_{i}$都已确定其取值。比如根结点$X=??????????$表示部分解，其中所有的边都尚未确定是否被环游使用；结点$X=1?????????$表示另一个部分解，表示仅已知环游使用了边$e_{1}$，其他边是否使用尚未确定；叶子结点$X=1011000011$表示一个完整解，对应于环游$a\rightarrow b \rightarrow c \rightarrow e \rightarrow d  \rightarrow a$。\uwave{树中的边}从一个部分解$X$指向另一个解$X'$，其中$X'$比$X$中多了1个分量确定了取值。
   
   我们还可以从另一个角度认识内部结点和部分解：一个叶子结点仅表示一个完整解，而一个内部结点则表示\uwave{一族完整解}，即以此内部结点为根的子树上所有叶子结点对应的完整解。
   	


\begin{figure}[htp]\centering
\begin{tikzpicture}[scale=.9, auto,swap]

	\def\x{3.4}; 
	\def\y{\x / 2}; 
	\def\z{\y / 2};
	\def\r{\z / 1.5};
	\def\d{0.1};
	\def\h{1};
	
%layer 1	
    \foreach \pos/\name/\label in {{(0,0)/root/}, {(-\x,-1*\h)/L/}, {(\x,-1*\h)/R/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 2	
    \def\base{-\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h)/LL/}, {( \base + \y,-2*\h)/LR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
    \def\base{\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h)/RL/}, {( \base + \y,-2*\h)/RR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 3	
%    \def\base{-\x - \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
    \def\base{-\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LRL/}, {( \base + \z,-3*\h)/LRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
    \def\base{\x - \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RLL/}, {( \base + \z,-3*\h)/RLR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
        
    \def\base{-\x - \y};
    \foreach \pos/\name/\label in {{( \base + \z, -3*\h)/LLR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	    

    \def\base{\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	    

%    \def\base{\x + \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}, {( \base + \z,-3*\h)/RRR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
   
 %layer 4 
%        \def\base{-\x + \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/LRLL/}, {( \base + \r,-4*\h)/LRLR/}}  
%        \node[tinyvertex,draw=black, fill=blue!20] (\name) at \pos {};	  
    \def\base{-\x - \y + \z};
    \foreach \pos/\name/\label in {{( \base + \r, -4*\h)/LLRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	  

    \def\base{-\x + \y + \z};
    \foreach \pos/\name/\label in {{( \base + \r, -4*\h)/LRRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	  
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/LRRL/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	  

%        \node[] at (-\x -\y, -3*\h ) {$\dots$}; 
%        \node[] at (-\x -\y + \z, -4*\h ) {$\dots$}; 

%        \node[] at (-\x +\y - \z, -4*\h ) {$\dots$}; 
%        \node[] at (-\x +\y + \z, -4*\h ) {$\dots$}; 
%        \node[] at (\x -\y + \z, -4*\h ) {$\dots$}; 
                 
    \def\base{\x - \y + \z};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/RLRL/}, {( \base + \r, -4*\h)/RLRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	     

    \def\base{\x + \y - \z};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/RRLL/}, {( \base + \r, -4*\h)/RRLR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	     

   %   \node[] at (\x - \y + \z, -4*\h ) {$\dots$}; 
 %     \node[] at (\x - \y - \z, -4*\h ) {$\dots$}; 

%      \node[] at (\x + \y, -3*\h ) {$\dots$}; 
%      \node[] at (\x + \y - \z, -4*\h ) {$\dots$}; 
   
   
           \def\base{\x - \y - \z};
           \def\r{\z/1.5};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/RLLL/}, {( \base + \r,-4*\h)/RLLR/}}  
        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  

           \def\base{-\x + \y - \z};
           \def\r{\z/1.5};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/LRLL/}, {( \base + \r,-4*\h)/LRLR/}}  
        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  

%%Layer 5 
%           \def\base{\x - \y + \z + \r};
%           \def\s{\z/1.5};
%    \foreach \pos/\name/\label in {{( \base - \s, -5*\h)/RLRRL/}, {( \base + \s,-5*\h)/RLRRR/}}  
%        \node[tinyvertex,draw=black,fill=white!20] (\name) at \pos {};	  
%
%%Layer 6 
%           \def\base{\x - \y + \z + \r + \s};
%           \def\t{\z/1.5};
%    \foreach \pos/\name/\label in {{( \base - \t, -6*\h)/RLRRRL/}, {( \base + \t,-6*\h)/RLRRRR/}}  
%        \node[tinyvertex,draw=black,fill=white!20] (\name) at \pos {};	  
%    \foreach \pos/\name/\label in {{( \base + \t,-6*\h)/RLRRRR/}}  
%        \node[tinyvertex,draw=black,fill=blue!20] (\name) at \pos {};	  

             
    % Connect vertices with edges and draw weights
  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
	%layer 2
	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	 \foreach \source/ \dest /\weight in {R/RL/{1}, RR/R/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	%layer 3
	 \foreach \source/ \dest /\weight in { LL/LLR/{x_3=0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	 \foreach \source/ \dest /\weight in {LR/LRL/{1}, LRR/LR/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
	
	\foreach \source/ \dest /\weight in {RL/RLL/{1}, RLR/RL/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	\foreach \source/ \dest /\weight in {RR/RRL/{1}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

%	 \foreach \source/ \dest /\weight in {RR/RRL/{0}, RRR/RR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
	
	%layer 4 
         \foreach \source/ \dest /\weight in {RLL/RLLL/{1}, RLLR/RLL/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
	\foreach \source/ \dest /\weight in {LRL/LRLL/{1}, LRLR/LRL/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

         \foreach \source/ \dest /\weight in {LLR/LLRR/{\dots\qquad x_4=0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

         \foreach \source/ \dest /\weight in {LRR/LRRL/{1}, LRRR/LRR/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

         \foreach \source/ \dest /\weight in {RLR/RLRL/{1}, RLRR/RLR/{0}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

         \foreach \source/ \dest /\weight in {RRL/RRLL/{1}, RRLR/RRL/{0\qquad \dots}}         
		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

%	%layer 5
%         \foreach \source/ \dest /\weight in {RLRR/RLRRL/{x_5=0}, RLRRR/RLRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%%         \foreach \source/ \dest /\weight in {RRR/RRRL/{0}, RRR/RRRR/{1}}         
%%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%
%	%layer 6
%         \foreach \source/ \dest /\weight in {RLRRR/RLRRRL/{x_6=0}, RLRRRR/RLRRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%         \foreach \source/ \dest /\weight in {RRR/RRRL/{0}, RRR/RRRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	
%label 			
    \foreach \pos/\name/\label in {{(0+\d,0)/root/X=??????????},  {(-\x+\d,-1*\h)/L/1?????????}, {(\x+\d,-1*\h)/R/0?????????}} 
        \node[right] at \pos {\tiny{ $\label$}};
%layer 2	
    \def\base{-\x};
    \foreach \pos/\name/\label in {{( \base + \y +\d,-2*\h)/LR/10????????}}  
        \node[right] at \pos {\tiny{ $\label$}};
    \foreach \pos/\name/\label in {{( \base - \y + \d, -2*\h)/LL/11????????}}  
        \node[right] at \pos {\tiny{ $\label$}};
            
    \def\base{\x};
    \foreach \pos/\name/\label in {{( \base - \y+\d, -2*\h)/RL/01????????}}  
        \node[right] at \pos {\tiny{ $\label$}};
    \foreach \pos/\name/\label in {{( \base + \y+\d,-2*\h)/RR/00????????}}  
        \node[right] at \pos {\tiny{ $\label$}};


%layer 3
    \def\base{-\x - \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
        \node[right] at \pos {\tiny{$\label$}};	 
             
    \def\base{-\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LRL/101?0?????}, {( \base + \z,-3*\h)/LRR/}}  
        \node[right] at \pos {\tiny{$\label$}};	 
    
    \def\base{\x - \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RLL/}, {( \base + \z,-3*\h)/RLR/}}  
        \node[right] at \pos {\tiny{$\label$}};	 

    \def\base{\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}, {( \base + \z,-3*\h)/RRR/}}  
        \node[right] at \pos {\tiny{$\label$}};	 
   
  
   
% %layer 4
%         \def\base{-\x + \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/LRLL/[0,1,0,0]}, {( \base + \r,-4*\h)/LRLR/[0,1,0,1]}}  
%        \node[below] at \pos {\tiny{$\label$}};	      
%         
%         \def\base{\x - \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/RLLL/[1,0,0,0]}, {( \base + \r,-4*\h)/RLLR/[1,0,0,1]}}  
%        \node[below] at \pos {\tiny{$\label$}};	      
     
      %layer 3
  %RLR 
%  \def\d{0.3};
%  \node[] at (\x - \y + \z + 0.2, -3*\h + \d ) {\tiny $010?1?????$}; 
  %RLL
 % \node[] at (\x - \y - \z + 0.5, -3*\h ) {\tiny $011?0?????$}; 
    
  %LRR 
%  \def\d{0.3};
%  \node[] at (-\x + \y + \z, -3*\h - \d ) {\tiny $100?1?????$}; 
  %LRL
 % \node[] at (\x - \y - \z + 0.5, -3*\h ) {\tiny $101?0?????$}; 
    
  %layer 4
 %RLLL
  \def\d{0.3};
  \node[red] at (\x - \y - \z - \r - 0.3, -4*\h - \d ) {\tiny $0111001001$}; 
 %RLLR
  \def\d{0.3};
  \node[red] at (\x - \y - \z + \r + 0.3, -4*\h - \d ) {\tiny $0110011010$}; 
 
  %RRLR
  \def\d{0.3};
  \node[] at (\x  + \y - \z + \r , -4*\h - \d ) {\tiny \dots }; 

  
%LRLL
  \def\d{0.3};
  \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d ) {\tiny $1011000011$}; 
 %LRLR
  \def\d{0.3};
  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d ) {\tiny $1010001110$}; 

  %RRLR
  \def\d{0.3};
  \node[] at (\x + \y - \z - \r , -4*\h - \d ) {\tiny \dots}; 

 
   \end{tikzpicture}
   \caption{\fangsong 枚举TSP可行解的部分解树。每个内部结点表示一个部分解，叶子结点表示一个完整解（即环游）；边表示设定某一个分量$x_{i}$的取值。}
   \label{TSPPartialSolutionTree}
\end{figure}
 
 \subsubsection*{朴素枚举算法}
    求解给定的TSP实例，可以通过枚举所有的可行解、然后选择里程最短的可行解来实现。我们可以采用如下策略来枚举所有的可行解：从根结点$X=??????????$开始，逐步构建出部分解树；每一步都选择一个未确定取值的分量$x_{i}$，分别尝试其两种取值$x_{i}=1$与$x_{i}=0$，从而扩展成两个新的结点；如此逐步增大能够确定取值的分量的个数，直至所有分量都确定取值，从而获得了完整可行解。这种朴素的枚举算法描述如下：
    
\begin{algorithm}[H]
\caption{Generic enumeration algorithm for TSP}\label{TSPEmumerationAlgo}   
{\bf function} {\sc GenericEnumerationAlgorithmForTSP$(V, D)$}	
\begin{algorithmic}[1]
\STATE{Let $A = \{X_0\}$. //Start with the root node $X_{0} = ??...?$, where $|X_{0}| = |V|$, $A$ denotes the active set of unexplored nodes}
\STATE{$best\_so\_far = \infty$};
\WHILE{$A \neq $ $\{\}$}
	\STATE \textcolor{red}{\bf Choose} and remove a node $X$ from $A$, 
	and select an undetermined item $x_{i}$ from $X$;
	\FOR{$v \in \{0, 1\}$}
		\STATE{\textcolor{red}{\bf Expand} $X$ into node $X'$ by setting $x_{i}=v$;}
		\IF {$X'$ represents a complete solution}
			\STATE Update $best\_so\_far$ if $X'$ has better objective function value;
		\ELSE
			\STATE Insert $X'$ into $A$; //$X'$ needs to be explored further; 
		\ENDIF
	\ENDFOR
%\IF { \textcolor{red}{\bf lowerbound$(P_i) \leq best\_so\_far$}  }
%\STATE insert $P_i$ into $A$;
%\ENDIF
\ENDWHILE
\RETURN{$best\_so\_far$};
\end{algorithmic}
\end{algorithm}

   由于存在指数多个完整可行解 ，因此需要指数多的运行时间才能构建出完整的部分解树、枚举出所有的可行解。即便对于规模较小的TSP实例，这种朴素的枚举算法往往也难以求解。为提高求解速度，一种常用的策略是对部分解树进行“\uwave{剪枝}”，即：$(i)$ 对于每个内部结点， 评估与其对应的部分解$X$的“质量”；$(ii)$ 在枚举中不扩展低质量的部分解，无需考虑由其扩展而成的完整解；直观上看，我们“剪掉”了以此结点为根的子树，从而降低了需要构建的部分解树的大小。  
    这种带剪枝的枚举策略被称为“\uwave{智能枚举}”(Intelligent enumeration \cite{PapadimitriouBook})。
   
\subsubsection*{“智能枚举”算法}    
	“智能枚举”算法的核心在于如何\uwave{评估部分解的质量}。对于一个完整解来说，我们可以精确计算出与其对应环游的里程；而对于一个部分解而言，我们仅仅知道环游的部分信息（如已知一些边被用、一些边肯定不会用），无法精确计算出环游的里程，因此只能估计部分解的质量。常用的估计量之一是部分解$X$所代表的\uwave{一族完整解的里程的下界}(Lower bound)，记为$LB(X)$，计算方法如下：
	
	\begin{itemize}
		\item 我们先考察特殊的部分解$X=??????????$。我们依次考察TSP实例中的所有结点，对每一个结点，从与其相邻接的$n-1$条边中选择最短的两条边，则共可获得$2n$条边。容易证明，此$2n$条边的里程之和的一半，是最短环游里程的下界。以图\ref{TSPSolutionForm}所示实例为例，我们可以计算出下界：
\[
	LB(X) = \tfrac{1}{2}(5+6+8+7+9)=17.5
\]		
		\item 对于一般的部分解$X$，我们只需对上述过程做小幅修改：在选择最短的两条邻接边时，需要满足部分解$X$蕴含的约束。以部分解$X=10????????$为例，$x_1 = 1$表示边$e_1$已使用，$x_2=0$表示边$e_2$不可使用，因此对结点$c$来说，最短的两条邻接边只能使用$e_4$和$e_8$，其和为9；从而下界是：
\[
	LB(X) = 	\tfrac{1}{2}(5+6+9+7+9)=18			
\]
	\end{itemize}

       利用部分解的下界信息进行剪枝的“智能枚举”算法称为“\uwave{分支限界法}”(Branch and bound)，描述如下：
\begin{algorithm}[H]
\caption{Intelligent enumeration algorithm for TSP}\label{TSPIntelligentEnumerationAlgo}   
{\bf function} {\sc IntelligentEnumerationForTSP$(V, D)$}	
\begin{algorithmic}[1]
\STATE{Let $A = \{X_0\}$; //Start with the root node $X_0=??...?$, where $|X_0| = |V|$, and $A$ denotes the active set of unexplored nodes.}
\STATE{$best\_so\_far = \infty$}; //Store the best tour till now; 
\WHILE{$A \neq $ $\{\}$}
	\STATE \textcolor{red}{\bf Choose} a node $X\in A$ such that \textcolor{red}{\bf $LB(X) \leq best\_so\_far$}, and remove $X$ from $A$;
	\STATE Select an undetermined item $x_i$ from $X$; 
	\FOR{$v=0$ to $1$}
		\STATE{Expand $X$ into node $X'$ by setting $x_i = v$;}
		\IF{$X'$  represents a complete solution }
			\STATE Update $best\_so\_far$ if $X'$ has better objective function value; 
		\ELSIF{\textcolor{red}{\bf $LB(X') \leq best\_so\_far$}  }
				\STATE \textcolor{red}{Insert $X'$ into $A$;} //$X'$ needs to be explored further;
%			\ENDIF
		\ENDIF
	\ENDFOR
\ENDWHILE
\RETURN{$best\_so\_far$};
\end{algorithmic}
\end{algorithm}

 与朴素的枚举算法相比，“智能枚举”算法只在两个地方有所不同：$(i)$ 当选择一个部分解$X$进行扩展时，增加了一个约束，要求$LB(X)$必须小于当前已获得的最好环游$best\_so\_far$（第4行）；$(ii)$ 向待扩展结点集$A$增加部分解$X$时，也增加了相同的约束（第11行）。换句话说，对于那些$LB(X)>best\_so\_far$的部分解$X$，与其对应的一族完整解不会优于现在已知的最好解$best\_so\_far$，因此无需进行扩展，从而实现了“剪枝”。
 
 对于图\ref{TSPSolutionForm}所示实例，算法{\sc IntelligentEnumerationForTSP}共需迭代执行7轮，其中前4轮迭代后生成的部分解树见图1.8。我们以第4轮迭代为例详细描述“剪枝”过程：算法选择部分解$X_{5}=101?0?????$进行扩展，在分别设置$x_{4}=1$与$x_{4}=0$并进行一些推理之后，生成两个完整解$X_{7}=1011000011$和$X_{8}=1010001110$，相应的环游里程分布为23和21，因而将$best\_so\_far$ 更新为 $21$；由于部分解$X_{6}$的下界$LB(X_{6})=23$大于$best\_so\_far$，意味即使扩展$X_{6}$也不会产生优于$X_{8}$的环游，因此我们从$A$中去除$X_{6}$。类似地，由于所有边上的距离都是整数，因此虽然$LB(X_{3})=20.5$，我们依然可以断定扩展$X_{3}$也不会产生优于$X_{8}$的完整解，从而将$X_{3}$从$A$中去除。
 
 当执行了7轮迭代之后（见图\ref{Step7}），所有的部分解要么被扩展，要么被剪枝；算法生成一棵仅有15个结点的部分解树，就求出了最优解$X_{4}=0111001001$，对应的环游里程为19。和朴素的枚举算法比较可见，“智能枚举”算法大大减少了所需考查的结点，从而显著提高了速度。
 
% 
%\begin{figure}\centering
%\begin{tikzpicture}[scale=1, auto,swap]
%
%%   \def\dx{0};
%%   \def\dy{1.1} 
%%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%%     
%%    % Connect vertices with edges and draw weights
%%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%%         
%%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%%        
%%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%%
%%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
% 
%%Tree
%
%	\def\x{3.4}; 
%	\def\y{\x / 2}; 
%	\def\z{\y / 2};
%	\def\r{\z / 1};
%	\def\d{0.1};
%	\def\h{1};
%
%% Label
%%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
%%\node[blue, ultra thick] at (3.7, 1.5 +\dy) {\small $A=\{X_1, X_2\}$}; 
%%\node[blue, ultra thick] at (3.8, 1.0 + \dy) {\small $best\_so\_far=+\infty$}; 
%%
%   \node at (-\x-\y-\z, -\h * 0.5)  {\tiny $x_1=1/0$};  
%
%%layer 1	
%    \foreach \pos/\name/\label in {{(0,0)/root/}, {(-\x,-1*\h)/L/}, {(\x,-1*\h)/R/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%
%             
%    % Connect vertices with edges and draw weights
%  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%
%	\def\d{0.3};
%%P2 right
%  \node[] at (\x  + 1.2, -1*\h  ) {\tiny  $0?????????$}; 
%  \node[] at (\x  + 1.2, -1*\h  -\d) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 
%
%%P1 right
%  \node[] at (-\x  + 1.2, -1*\h  ) {\tiny  $1?????????$}; 
%  \node[] at (-\x  + 1.2, -1*\h  -\d) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 
%
%%P0 right
%  \node[] at ( + 1.4, 0  ) {\tiny  $X=??????????$}; 
%  \node[] at ( + 1.9,   -\d) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 
%
%   \end{tikzpicture}
%   \label{Step1}
%   \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行1轮后产生的部分解树。$A=\{X_1, X_2\}$，$best\_so\_far=+\infty$。 }
%\end{figure}


\begin{figure}\centering
\begin{tikzpicture}[scale=1, auto,swap]

%Step 1

%   \def\dx{0};
%   \def\dy{1.1} 
%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%     
%    % Connect vertices with edges and draw weights
%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%         
%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%        
%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%
%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
 
%Tree

	\def\x{3.4}; 
	\def\y{\x / 2}; 
	\def\z{\y / 2};
	\def\r{\z / 1};
	\def\d{0.1};
	\def\h{1};
	
	\def\dy{0};

% Label
%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
\node[blue, ultra thick] at (4, 0 +\dy) {\small $A=\{X_1, X_2\}$}; 
\node[blue, ultra thick] at (4, -0.5 + \dy) {\small $best\_so\_far=+\infty$}; 
%
   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  

%layer 1	
    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};

             
    % Connect vertices with edges and draw weights
  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	\def\d{0.3};
%P2 right
  \node[] at (\x  + 1.2, -1*\h   + \dy) {\tiny  $0?????????$}; 
  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 

%P1 right
  \node[] at (-\x  + 1.2, -1*\h   + \dy) {\tiny  $1?????????$}; 
  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 

%P0 right
  \node[] at ( + 1.4, 0   + \dy) {\tiny  $X=??????????$}; 
  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 
  
 \node[ultra thick ] at (0, -1*\h - 0.5 + \dy ) {$(a)$};  

%Step2
%   \def\dx{0};
%   \def\dy{1.1} 
%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%     
%    % Connect vertices with edges and draw weights
%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%         
%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%        
%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%
%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
% 
 
%Tree

	\def\x{3.4}; 
	\def\y{\x / 2}; 
	\def\z{\y / 2};
	\def\r{\z / 1};
	\def\d{0.3};
	\def\h{1};
	
	\def\dy{-2.5};
% Label
%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
\node[blue, ultra thick] at (4, 0 +\dy) {\small $A=\{X_2, X_3, X_4\}$}; 
\node[blue, ultra thick] at (4, -0.5 + \dy) {\small $best\_so\_far=+\infty$}; 

	
   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  
   \node at (-\x-\y-\z, -\h * 1.5 + \dy)  {\tiny $x_2=1/0$};  
 
%layer 1	
    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 2	
    \def\base{-\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/LL/}, {( \base + \y,-2*\h + \dy)/LR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
 
          
    % Connect vertices with edges and draw weights
  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	%layer 2
	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	

%P3 right
  \node[] at (-\x - \y + 1, -2*\h   + \dy) {\tiny  $110?0?????$}; 
  \node[] at (-\x - \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{3} \textcolor{blue}{(20.5)}$}; 

%P4 right
  \node[] at (-\x + \y + 1, -2*\h   + \dy) {\tiny  $10????????$}; 
  \node[] at (-\x + \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{4} \textcolor{blue}{(18)}$}; 

%P2 right
  \node[] at (\x  + 1.2, -1*\h  + \dy ) {\tiny  $0?????????$}; 
  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 

%P1 right
  \node[] at (-\x  + 1.2, -1*\h   + \dy) {\tiny  $1?????????$}; 
  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 

%P0 right
  \node[] at ( + 1.4, 0   + \dy) {\tiny  $X=??????????$}; 
  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 

  
  \node[ultra thick ] at (0, -2*\h - 0.7 + \dy ) {$(b)$};  

  
%   \end{tikzpicture}
%   \label{Step2}
%   \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行2轮后产生的部分解树。$A=\{X_2, X_3, X_4\}$，$best\_so\_far=+\infty$。}  
%\end{figure}
%
% 
% \begin{figure}\centering
%\begin{tikzpicture}[scale=1, auto,swap]

%   \def\dx{0};
%   \def\dy{1.1} 
%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%     
%    % Connect vertices with edges and draw weights
%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%         
%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%        
%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%
%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
 
 
%Tree

	\def\x{3.4}; 
	\def\y{\x / 2}; 
	\def\z{\y / 2};
	\def\r{\z / 1};
	\def\d{0.3};
	\def\h{1};

	\def\dy{-6.3};

% Label
%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
\node[blue, ultra thick] at (4.0, 0 + \dy) {\small $A=\{X_2, X_3, X_5, X_6\}$}; 
\node[blue, ultra thick] at (4.0, -0.5 + \dy) {\small $best\_so\_far=+\infty$}; 

	
   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  
   \node at (-\x-\y-\z, -\h * 1.5 + \dy)  {\tiny $x_2=1/0$};  
   \node at (-\x-\y-\z, -\h * 2.5 + \dy)  {\tiny $x_3=1/0$};  
%   \node at (-\x-\y-\z, -\h * 3.5)  {\tiny $x_4=1/0$};  

%layer 1	
    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 2	
    \def\base{-\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/LL/}, {( \base + \y,-2*\h + \dy)/LR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
%layer 3	
%    \def\base{-\x - \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
    \def\base{-\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/LRL/}, {( \base + \z,-3*\h + \dy)/LRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
             
    % Connect vertices with edges and draw weights
  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	%layer 2
	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	%layer 3
	 \foreach \source/ \dest /\weight in {LR/LRL/{x_3=1}, LRR/LR/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	


%P3 right
  \node[] at (-\x - \y + 1, -2*\h   + \dy) {\tiny  $110?0?????$}; 
  \node[] at (-\x - \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{3} \textcolor{blue}{(20.5)}$}; 

%P4 right
  \node[] at (-\x + \y + 1, -2*\h   + \dy) {\tiny  $10????????$}; 
  \node[] at (-\x + \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{4} \textcolor{blue}{(18)}$}; 

%P2 right
  \node[] at (\x  + 1.2, -1*\h   + \dy) {\tiny  $0?????????$}; 
  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 

%P1 right
  \node[] at (-\x  + 1.2, -1*\h   + \dy) {\tiny  $1?????????$}; 
  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 

%P0 right
  \node[] at ( + 1.4, 0   + \dy) {\tiny  $X=??????????$}; 
  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 

%P6 below
  \node[] at (-\x + \y +\z, -3*\h - \d  + \dy) {\tiny  $100?1?????$}; 
  \node[] at (-\x + \y +\z, -3*\h - \d -\d + \dy) {\tiny  $X_{6} \textcolor{blue}{(23)}$}; 

%P5 below
  \node[] at (-\x + \y -\z, -3*\h - \d  + \dy) {\tiny  $101?0?????$}; 
  \node[] at (-\x + \y -\z, -3*\h  -\d -\d + \dy) {\tiny  $X_{5} \textcolor{blue}{(18)}$}; 

\node[ultra thick ] at (0, -3*\h - 0.75 + \dy ) {$(c)$};  


%   \end{tikzpicture}
%   \label{Step3}
%   \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行3轮后产生的部分解树。$A=\{X_2, X_3, X_5, X_6\}$，$best\_so\_far=+\infty$。}
%\end{figure}
%
%\begin{figure}\centering
%\begin{tikzpicture}[scale=1, auto,swap]

%   \def\dx{0};
%   \def\dy{1.1} 
%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%     
%    % Connect vertices with edges and draw weights
%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%         
%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%        
%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%
%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
 
 
%Tree

	\def\x{3.4}; 
	\def\y{\x / 2}; 
	\def\z{\y / 2};
	\def\r{\z / 1};
	\def\d{0.3};
	\def\h{1};
	
		\def\dy{-11};

% Label
%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
\node[blue, ultra thick] at (4, 0+ \dy) {\small $A=\{X_2, X_{3}, X_6 \}$}; 
\node[blue, ultra thick] at (4, -0.5+ \dy) {\small $best\_so\_far=21$}; 
	
   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  
   \node at (-\x-\y-\z, -\h * 1.5 + \dy)  {\tiny $x_2=1/0$};  
   \node at (-\x-\y-\z, -\h * 2.5 + \dy)  {\tiny $x_3=1/0$};  
   \node at (-\x-\y-\z, -\h * 3.5 + \dy)  {\tiny $x_4=1/0$};  

%layer 1	
    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 2	
    \def\base{-\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/LL/}, {( \base + \y,-2*\h + \dy)/LR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
%layer 3	
    \def\base{-\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/LRL/}, {( \base + \z,-3*\h + \dy)/LRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
 %layer 4 
                 
           \def\base{-\x + \y - \z};
           \def\r{\z/1.5};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h + \dy)/LRLL/}, {( \base + \r,-4*\h + \dy)/LRLR/}}  
        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  

             
    % Connect vertices with edges and draw weights
  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	%layer 2
	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	%layer 3
	 \foreach \source/ \dest /\weight in {LR/LRL/{x_3=1}, LRR/LR/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	
	%layer 4 
	\foreach \source/ \dest /\weight in {LRL/LRLL/{x_4=1}, LRLR/LRL/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	
  
  %layer 4
   
%LRLL
  \def\d{0.3};
  \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  + \dy) {\tiny   $1011000011$}; 
    \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  -\d + \dy) {\tiny  $X_{7} (23)$}; 

 %LRLR
  \def\d{0.3};
  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d  + \dy) {\tiny  $1010001110$}; 
  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d -\d + \dy) {\tiny  $X_{8} (21)$}; 

%P3 right
  \node[] at (-\x - \y + 1, -2*\h   + \dy) {\tiny  $110?0?????$}; 
  \node[] at (-\x - \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{3} \textcolor{blue}{(20.5)}$ \textcolor{red}{\bf X}}; 

%P4 right
  \node[] at (-\x + \y + 1, -2*\h   + \dy) {\tiny  $10????????$}; 
  \node[] at (-\x + \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{4} \textcolor{blue}{(18)}$}; 

%P2 right
  \node[] at (\x  + 1.2, -1*\h   + \dy) {\tiny  $0?????????$}; 
  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 

%P1 right
  \node[] at (-\x  + 1.2, -1*\h   + \dy) {\tiny  $1?????????$}; 
  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 

%P0 right
  \node[] at ( + 1.4, 0   + \dy) {\tiny  $X=??????????$}; 
  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 

%P6 below
  \node[] at (-\x + \y +\z, -3*\h - \d  + \dy) {\tiny  $100?1?????$}; 
  \node[] at (-\x + \y +\z, -3*\h - \d -\d + \dy) {\tiny  $X_{6} \textcolor{blue}{(23)}$ \textcolor{red}{\bf X}}; 

%P5 left
  \node[] at (-\x + \y -\z - 1, -3*\h  + \dy ) {\tiny  $101?0?????$}; 
  \node[] at (-\x + \y -\z - 1, -3*\h  -\d + \dy) {\tiny  $X_{5} \textcolor{blue}{(18)}$}; 

   \node[ultra thick ] at (0, -4*\h - 0.6 + \dy ) {$(d)$};  

  
   \end{tikzpicture}
   \label{Stepssss}
   \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行1-4轮产生的部分解树。}
\end{figure}

%
% \begin{figure}\centering
%\begin{tikzpicture}[scale=1, auto,swap]
%
%%   \def\dx{0};
%%   \def\dy{1.1} 
%%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%%     
%%    % Connect vertices with edges and draw weights
%%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%%         
%%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%%        
%%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%%
%%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
%% 
% 
%%Tree
%
%	\def\x{3.4}; 
%	\def\y{\x / 2}; 
%	\def\z{\y / 2};
%	\def\r{\z / 1};
%	\def\d{0.3};
%	\def\h{1};
%
%	\def\dy{0};
%
%% Label
%%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
%%\node[blue, ultra thick] at (4, 1.5) {\small $A=\{X_9 \}$}; 
%%\node[blue, ultra thick] at (4, 1.0) {\small $best\_so\_far=21$}; 
%	
%   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  
%   \node at (-\x-\y-\z, -\h * 1.5 + \dy)  {\tiny $x_2=1/0$};  
%   \node at (-\x-\y-\z, -\h * 2.5 + \dy)  {\tiny $x_3=1/0$};  
%   \node at (-\x-\y-\z, -\h * 3.5 + \dy)  {\tiny $x_4=1/0$};  
%
%%layer 1	
%    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%%layer 2	
%    \def\base{-\x};
%    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/LL/}, {( \base + \y,-2*\h + \dy)/LR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%    
%    \def\base{\x};
%    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/RL/}, {( \base + \y,-2*\h + \dy)/RR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%%layer 3	
%%    \def\base{-\x - \y};
%%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
%%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
%    \def\base{-\x + \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/LRL/}, {( \base + \z,-3*\h + \dy)/LRR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%    
%%    \def\base{\x + \y};
%%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}, {( \base + \z,-3*\h)/RRR/}}  
%%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%   
% %layer 4 
%   
%
%           \def\base{-\x + \y - \z};
%           \def\r{\z/1.5};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h + \dy)/LRLL/}, {( \base + \r,-4*\h + \dy)/LRLR/}}  
%        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  
%
%             
%    % Connect vertices with edges and draw weights
%  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%	%layer 2
%	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%
%	 \foreach \source/ \dest /\weight in {R/RL/{1}, RR/R/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%
%	%layer 3
%	 \foreach \source/ \dest /\weight in {LR/LRL/{x_3=1}, LRR/LR/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%	
%	%layer 4 
%	\foreach \source/ \dest /\weight in {LRL/LRLL/{x_4=1}, LRLR/LRL/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%	
%    
%  %layer 4
%
%%LRLL
%  \def\d{0.3};
%  \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  + \dy) {\tiny   $1011000011$}; 
%    \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  -\d + \dy) {\tiny  $X_{7} (23)$}; 
%
% %LRLR
%  \def\d{0.3};
%  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d  + \dy) {\tiny  $1010001110$}; 
%  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d -\d + \dy) {\tiny  $X_{8} (21)$}; 
%
%%P10 right
%  \node[] at (\x + \y + 1, -2*\h  + \dy) {\tiny  $001?1?????$}; 
%  \node[] at (\x + \y + 1, -2*\h -\d + \dy) {\tiny  $X_{10} \textcolor{blue}{(21)}$ \textcolor{red}{\bf X}}; 
%
%%P9 right 
%  \node[] at (\x - \y + 1, -2*\h   + \dy) {\tiny  $01????????$}; 
%  \node[] at (\x - \y + 1, -2*\h -\d + \dy) {\tiny  $X_{9} \textcolor{blue}{(18.5)}$}; 
%
%%P3 right
%  \node[] at (-\x - \y + 1, -2*\h  + \dy ) {\tiny  $110?0?????$}; 
%  \node[] at (-\x - \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{3} \textcolor{blue}{(20.5)}$ \textcolor{red}{\bf X}}; 
%
%%P4 right
%  \node[] at (-\x + \y + 1, -2*\h  + \dy ) {\tiny  $10????????$}; 
%  \node[] at (-\x + \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{4} \textcolor{blue}{(18)}$}; 
%
%%P2 right
%  \node[] at (\x  + 1.2, -1*\h  + \dy ) {\tiny  $0?????????$}; 
%  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 
%
%%P1 right
%  \node[] at (-\x  + 1.2, -1*\h  + \dy ) {\tiny  $1?????????$}; 
%  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 
%
%%P0 right
%  \node[] at ( + 1.4, 0  + \dy ) {\tiny  $X=??????????$}; 
%  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 
%
%%P6 below
%  \node[] at (-\x + \y +\z, -3*\h - \d + \dy ) {\tiny  $100?1?????$}; 
%  \node[] at (-\x + \y +\z, -3*\h - \d -\d + \dy) {\tiny  $X_{6} \textcolor{blue}{(23)}$ \textcolor{red}{\bf X}}; 
%
%%P5 left
%  \node[] at (-\x + \y -\z - 1, -3*\h   + \dy) {\tiny  $101?0?????$}; 
%  \node[] at (-\x + \y -\z - 1, -3*\h  -\d + \dy) {\tiny  $X_{5} \textcolor{blue}{(18)}$}; 
%
%   
%  
%   \end{tikzpicture}
%   \label{Step5}
%   \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行5轮后产生的部分解树。$A=\{X_9 \}$，$best\_so\_far=21$。}
%\end{figure}
%
% 
% 
% \begin{figure}
%\begin{tikzpicture}[scale=1, auto,swap]
%
%%   \def\dx{0};
%%   \def\dy{1.1} 
%%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%%     
%%    % Connect vertices with edges and draw weights
%%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%%         
%%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%%        
%%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%%
%%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
%% 
% 
%%Tree
%
%	\def\x{3.4}; 
%	\def\y{\x / 2}; 
%	\def\z{\y / 2};
%	\def\r{\z / 1};
%	\def\d{0.3};
%	\def\h{1};
%	
%	\def\dy{0};
%
%%% Label
%%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
%%\node[blue, ultra thick] at (4, 1.5) {\small $A=\{X_{11} \}$}; 
%%\node[blue, ultra thick] at (4, 1.0) {\small $best\_so\_far=21$}; 
%	
%   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  
%   \node at (-\x-\y-\z, -\h * 1.5 + \dy)  {\tiny $x_2=1/0$};  
%   \node at (-\x-\y-\z, -\h * 2.5 + \dy)  {\tiny $x_3=1/0$};  
%   \node at (-\x-\y-\z, -\h * 3.5 + \dy)  {\tiny $x_4=1/0$};  
%
%%layer 1	
%    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%%layer 2	
%    \def\base{-\x};
%    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/LL/}, {( \base + \y,-2*\h + \dy)/LR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%    
%    \def\base{\x};
%    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/RL/}, {( \base + \y,-2*\h + \dy)/RR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%%layer 3	
%%    \def\base{-\x - \y};
%%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
%%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
%    \def\base{-\x + \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/LRL/}, {( \base + \z,-3*\h + \dy)/LRR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%    
%    \def\base{\x - \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/RLL/}, {( \base + \z,-3*\h + \dy)/RLR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
%%    \def\base{\x + \y};
%%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}, {( \base + \z,-3*\h)/RRR/}}  
%%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%   
% %layer 4 
%   
%           \def\base{-\x + \y - \z};
%           \def\r{\z/1.5};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h + \dy)/LRLL/}, {( \base + \r,-4*\h + \dy)/LRLR/}}  
%        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  
%
%
%        
%    % Connect vertices with edges and draw weights
%  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%	%layer 2
%	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%
%	 \foreach \source/ \dest /\weight in {R/RL/{1}, RR/R/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%
%	%layer 3
%%	 \foreach \source/ \dest /\weight in {LL/LLL/{x_3=0}, LLR/LL/{1}}         
%%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%
%	 \foreach \source/ \dest /\weight in {LR/LRL/{x_3=1}, LRR/LR/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%	
%	\foreach \source/ \dest /\weight in {RL/RLL/{1}, RLR/RL/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%
%	%layer 4 
%	\foreach \source/ \dest /\weight in {LRL/LRLL/{x_4=1}, LRLR/LRL/{0}}         
%		\path[undirectededge] (\source) -- node[weight] { } (\dest);
%	
%    
%  %layer 4
%  
%%LRLL
%  \def\d{0.3};
%  \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  + \dy) {\tiny   $1011000011$}; 
%    \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  -\d + \dy) {\tiny  $X_{7} (23)$}; 
%
% %LRLR
%  \def\d{0.3};
%  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d  + \dy) {\tiny  $1010001110$}; 
%  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d -\d + \dy) {\tiny  $X_{8} (21)$}; 
%
%%P10 right
%  \node[] at (\x + \y + 1, -2*\h  + \dy) {\tiny  $001?1?????$}; 
%  \node[] at (\x + \y + 1, -2*\h -\d + \dy) {\tiny  $X_{10} \textcolor{blue}{(21)}$ \textcolor{red}{\bf X}}; 
%
%%P9 right 
%  \node[] at (\x - \y + 1, -2*\h  + \dy ) {\tiny  $01????????$}; 
%  \node[] at (\x - \y + 1, -2*\h -\d + \dy) {\tiny  $X_{9} \textcolor{blue}{(18.5)}$}; 
%
%
%%P11 right
%  \node[] at (\x - \y -\z + 0.85, -3*\h  + \dy ) {\tiny  $011?0?????$}; 
%  \node[] at (\x - \y -\z + 0.85, -3*\h  -\d + \dy) {\tiny  $X_{11} \textcolor{blue}{(18.5)}$}; 
%
%%P12 right
%  \node[] at (\x - \y +\z + 1, -3*\h  + \dy ) {\tiny  $010?1?????$}; 
%  \node[] at (\x - \y +\z + 1, -3*\h  -\d + \dy) {\tiny  $X_{12} \textcolor{blue}{(23.5)}$ \textcolor{red}{\bf X}}; 
%
%%P3 right
%  \node[] at (-\x - \y + 1, -2*\h  + \dy ) {\tiny  $110?0?????$}; 
%  \node[] at (-\x - \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{3} \textcolor{blue}{(20.5)}$ \textcolor{red}{\bf X}}; 
%
%%P4 right
%  \node[] at (-\x + \y + 1, -2*\h  + \dy ) {\tiny  $10????????$}; 
%  \node[] at (-\x + \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{4} \textcolor{blue}{(18)}$}; 
%
%%P2 right
%  \node[] at (\x  + 1.2, -1*\h   + \dy) {\tiny  $0?????????$}; 
%  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 
%
%%P1 right
%  \node[] at (-\x  + 1.2, -1*\h  + \dy ) {\tiny  $1?????????$}; 
%  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 
%
%%P0 right
%  \node[] at ( + 1.4, 0  + \dy ) {\tiny  $X=??????????$}; 
%  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 
%
%%P6 below
%  \node[] at (-\x + \y +\z, -3*\h - \d  + \dy) {\tiny  $100?1?????$}; 
%  \node[] at (-\x + \y +\z, -3*\h - \d -\d + \dy) {\tiny  $X_{6} \textcolor{blue}{(23)}$ \textcolor{red}{\bf X}}; 
%
%%P5 left
%  \node[] at (-\x + \y -\z - 1, -3*\h  + \dy ) {\tiny  $101?0?????$}; 
%  \node[] at (-\x + \y -\z - 1, -3*\h  -\d + \dy) {\tiny  $X_{5} \textcolor{blue}{(18)}$}; 
%
%   
%  
%  
%   \end{tikzpicture}
%  \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行6轮后产生的部分解树。$A=\{X_{11} \}$，$best\_so\_far=21$。}
%  \label{Step6}
%\end{figure}
%
 
   
\begin{figure}\centering
\begin{tikzpicture}[scale=1, auto,swap]

%    \def\dx{0};
%   \def\dy{0.9} 
%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%     
%    % Connect vertices with edges and draw weights
%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%         
%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%        
%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%        \path[undirectededge, blue] (\source) -- node[weight] {$\weight$} (\dest);
%
%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
 
%Tree

	\def\x{3.4}; 
	\def\y{\x / 2}; 
	\def\z{\y / 2};
	\def\r{\z / 1};
	\def\d{0.3};
	\def\h{1};
	
		\def\dy{0};

% Label
%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
%\node[blue, ultra thick] at (4, 1.5) {\small $A=\{\}$}; 
%\node[blue, ultra thick] at (4, 1.0) {\small $best\_so\_far=19$}; 
	
   \node at (-\x-\y-\z, -\h * 0.5 + \dy)  {\tiny $x_1=1/0$};  
   \node at (-\x-\y-\z, -\h * 1.5 + \dy)  {\tiny $x_2=1/0$};  
   \node at (-\x-\y-\z, -\h * 2.5 + \dy)  {\tiny $x_3=1/0$};  
   \node at (-\x-\y-\z, -\h * 3.5 + \dy)  {\tiny $x_4=1/0$};  

%layer 1	
    \foreach \pos/\name/\label in {{(0,0 + \dy)/root/}, {(-\x,-1*\h + \dy)/L/}, {(\x,-1*\h + \dy)/R/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 2	
    \def\base{-\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/LL/}, {( \base + \y,-2*\h + \dy)/LR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
    \def\base{\x};
    \foreach \pos/\name/\label in {{( \base - \y, -2*\h + \dy)/RL/}, {( \base + \y,-2*\h + \dy)/RR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 3	
%    \def\base{-\x - \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
    \def\base{-\x + \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/LRL/}, {( \base + \z,-3*\h + \dy)/LRR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
    
    \def\base{\x - \y};
    \foreach \pos/\name/\label in {{( \base - \z, -3*\h + \dy)/RLL/}, {( \base + \z,-3*\h + \dy)/RLR/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	      
%    \def\base{\x + \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}, {( \base + \z,-3*\h)/RRR/}}  
%        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
   
 %layer 4 
        \def\base{-\x + \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/LRLL/}, {( \base + \r,-4*\h)/LRLR/}}  
%        \node[tinyvertex,draw=black, fill=blue!20] (\name) at \pos {};	  

%        \node[] at (-\x -\y, -3*\h ) {$\dots$}; 
%        \node[] at (-\x -\y + \z, -4*\h ) {$\dots$}; 

%        \node[] at (-\x +\y - \z, -4*\h ) {$\dots$}; 
%        \node[] at (-\x +\y + \z, -4*\h ) {$\dots$}; 
%        \node[] at (\x -\y + \z, -4*\h ) {$\dots$}; 
                 
        \def\base{\x - \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/RLLL/}, {( \base + \r, -4*\h)/RLLR/}}  
%        \node[tinyvertex,draw=black, fill=blue!20] (\name) at \pos {};	     

   %   \node[] at (\x - \y + \z, -4*\h ) {$\dots$}; 
 %     \node[] at (\x - \y - \z, -4*\h ) {$\dots$}; 

%      \node[] at (\x + \y, -3*\h ) {$\dots$}; 
%      \node[] at (\x + \y - \z, -4*\h ) {$\dots$}; 
   
   
           \def\base{\x - \y - \z};
           \def\r{\z/1.5};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h + \dy)/RLLL/}, {( \base + \r,-4*\h + \dy)/RLLR/}}  
        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  

           \def\base{-\x + \y - \z};
           \def\r{\z/1.5};
    \foreach \pos/\name/\label in {{( \base - \r, -4*\h + \dy)/LRLL/}, {( \base + \r,-4*\h + \dy)/LRLR/}}  
        \node[tinyvertex,draw=black,fill=red] (\name) at \pos {};	  

%%Layer 5 
%           \def\base{\x - \y + \z + \r};
%           \def\s{\z/1.5};
%    \foreach \pos/\name/\label in {{( \base - \s, -5*\h)/RLRRL/}, {( \base + \s,-5*\h)/RLRRR/}}  
%        \node[tinyvertex,draw=black,fill=white!20] (\name) at \pos {};	  
%
%%Layer 6 
%           \def\base{\x - \y + \z + \r + \s};
%           \def\t{\z/1.5};
%    \foreach \pos/\name/\label in {{( \base - \t, -6*\h)/RLRRRL/}, {( \base + \t,-6*\h)/RLRRRR/}}  
%        \node[tinyvertex,draw=black,fill=white!20] (\name) at \pos {};	  
%    \foreach \pos/\name/\label in {{( \base + \t,-6*\h)/RLRRRR/}}  
%        \node[tinyvertex,draw=black,fill=blue!20] (\name) at \pos {};	  

             
    % Connect vertices with edges and draw weights
  	\foreach \source/ \dest /\weight in {root/L/{x_1=1}, R/root/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	%layer 2
	 \foreach \source/ \dest /\weight in {L/LL/{x_2=1}, LR/L/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	 \foreach \source/ \dest /\weight in {R/RL/{1}, RR/R/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	%layer 3
%	 \foreach \source/ \dest /\weight in {LL/LLL/{x_3=0}, LLR/LL/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	 \foreach \source/ \dest /\weight in {LR/LRL/{x_3=1}, LRR/LR/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	
	\foreach \source/ \dest /\weight in {RL/RLL/{1}, RLR/RL/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

%	 \foreach \source/ \dest /\weight in {RR/RRL/{0}, RRR/RR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
	
	%layer 4 
         \foreach \source/ \dest /\weight in {RLL/RLLL/{1}, RLLR/RLL/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	\foreach \source/ \dest /\weight in {LRL/LRLL/{x_4=1}, LRLR/LRL/{0}}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	
%         \foreach \source/ \dest /\weight in {RRR/RRRL/{0}, RRR/RRRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%	%layer 5
%         \foreach \source/ \dest /\weight in {RLRR/RLRRL/{x_5=0}, RLRRR/RLRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%%         \foreach \source/ \dest /\weight in {RRR/RRRL/{0}, RRR/RRRR/{1}}         
%%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%
%	%layer 6
%         \foreach \source/ \dest /\weight in {RLRRR/RLRRRL/{x_6=0}, RLRRRR/RLRRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);
%         \foreach \source/ \dest /\weight in {RRR/RRRL/{0}, RRR/RRRR/{1}}         
%		\path[undirectededge] (\source) -- node[weight] {\tiny{$\weight$} } (\dest);

	
%%label 			
%    \foreach \pos/\name/\label in {{(0+\d,0)/root/{X_0\textcolor{blue}{(17.5)}: X=??????????} },  {(-\x+\d,-1*\h)/L/{X_1\textcolor{blue}{(17.5)}: 1?????????}}, {(\x+\d,-1*\h)/R/{X_2\textcolor{blue}{(18.5)}: 0?????????}}} 
%        \node[right] at \pos {\tiny{ }};
%%layer 2	
%    \def\base{-\x};
%    \foreach \pos/\name/\label in {{( \base + \y +\d,-2*\h)/LR/{X_{4}\textcolor{blue}{(18)}: 10????????}}}  
%        \node[right] at \pos {\tiny{ }};
%    \foreach \pos/\name/\label in {{( \base - \y + \d, -2*\h)/LL/{X_3\textcolor{blue}{(20.5)}: 11????????}}}  
%        \node[below] at \pos {\tiny{ }};
%            
%    \def\base{\x};
%    \foreach \pos/\name/\label in {{( \base - \y+\d, -2*\h)/RL/{X_9\textcolor{blue}{(18.5)}: 01????????}}}  
%        \node[right] at \pos {\tiny{ }};
%    \foreach \pos/\name/\label in {{( \base + \y+\d,-2*\h)/RR/{X_{10}\textcolor{blue}{(21)}: 00????????}}}  
%        \node[below] at \pos {\tiny{ }};
%
%
%%layer 3
%    \def\base{-\x - \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LLL/}, {( \base + \z,-3*\h)/LLR/}}  
%        \node[right] at \pos {\tiny{$\label$}};	 
%             
%    \def\base{-\x + \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/LRL/}, {( \base + \z,-3*\h)/LRR/}}  
%        \node[right] at \pos {\tiny{$\label$}};	 
%    
%    \def\base{\x - \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RLL/}, {( \base + \z,-3*\h)/RLR/}}  
%        \node[right] at \pos {\tiny{$\label$}};	 
%
%    \def\base{\x + \y};
%    \foreach \pos/\name/\label in {{( \base - \z, -3*\h)/RRL/}, {( \base + \z,-3*\h)/RRR/}}  
%        \node[right] at \pos {\tiny{$\label$}};	 
%     
   
 %layer 4
%         \def\base{-\x + \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/LRLL/[0,1,0,0]}, {( \base + \r,-4*\h)/LRLR/[0,1,0,1]}}  
%        \node[below] at \pos {\tiny{$\label$}};	      
%         
%         \def\base{\x - \y - \z};
%    \foreach \pos/\name/\label in {{( \base - \r, -4*\h)/RLLL/[1,0,0,0]}, {( \base + \r,-4*\h)/RLLR/[1,0,0,1]}}  
%        \node[below] at \pos {\tiny{$\label$}};	      
%     
      %layer 3
%  %RLR 
%  \def\d{0.3};
%  \node[] at (\x - \y + \z, -3*\h - \d ) {\tiny $X_{12}\textcolor{blue}{(23.5)}$: $010?1?????$}; 
%  %RLL
% % \node[] at (\x - \y - \z + 0.5, -3*\h ) {\tiny $011?0?????$}; 
%    
%  %LRR 
%  \def\d{0.3};
%  \node[] at (-\x + \y + \z, -3*\h - \d ) {\tiny  $X_{6}\textcolor{blue}{(23)}$: $100?1?????$}; 
  %LRL
 % \node[] at (\x - \y - \z + 0.5, -3*\h ) {\tiny $101?0?????$}; 
    
  %layer 4
 %RLLL
  \def\d{0.3};
  \node[red] at (\x - \y - \z - \r - 0.3, -4*\h - \d  + \dy) {\tiny   $0111001001$}; 
  \node[red] at (\x - \y - \z - \r - 0.3, -4*\h - \d - \d + \dy) {\tiny  $X_{13} (19)$}; 

 %RLLR
  \def\d{0.3};
  \node[red] at (\x - \y - \z + \r + 0.3, -4*\h - \d  + \dy) {\tiny  $0110011010$}; 
  \node[red] at (\x - \y - \z + \r + 0.3, -4*\h - \d -\d  + \dy) {\tiny  $X_{14} (23)$}; 
  
%LRLL
  \def\d{0.3};
  \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  + \dy) {\tiny   $1011000011$}; 
    \node[red] at (-\x + \y - \z - \r - 0.3, -4*\h - \d  -\d + \dy) {\tiny  $X_{7} (23)$}; 

 %LRLR
  \def\d{0.3};
  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d  + \dy) {\tiny  $1010001110$}; 
  \node[red] at (-\x + \y - \z + \r + 0.3, -4*\h - \d -\d + \dy) {\tiny  $X_{8} (21)$}; 

%P10 right
  \node[] at (\x + \y + 1, -2*\h  + \dy) {\tiny  $001?1?????$}; 
  \node[] at (\x + \y + 1, -2*\h -\d + \dy) {\tiny  $X_{10} \textcolor{blue}{(21)}$ \textcolor{red}{\bf X}}; 

%P9 right 
  \node[] at (\x - \y + 1, -2*\h   + \dy) {\tiny  $01????????$}; 
  \node[] at (\x - \y + 1, -2*\h -\d + \dy) {\tiny  $X_{9} \textcolor{blue}{(18.5)}$}; 

%P11 right
  \node[] at (\x - \y -\z + 0.85, -3*\h   + \dy) {\tiny  $011?0?????$}; 
  \node[] at (\x - \y -\z + 0.85, -3*\h  -\d + \dy) {\tiny  $X_{11} \textcolor{blue}{(18.5)}$}; 

%P12 right
  \node[] at (\x - \y +\z + 1, -3*\h  + \dy ) {\tiny  $010?1?????$}; 
  \node[] at (\x - \y +\z + 1, -3*\h  -\d + \dy) {\tiny  $X_{12} \textcolor{blue}{(23.5)}$ \textcolor{red}{\bf X}}; 

%P3 right
  \node[] at (-\x - \y + 1, -2*\h   + \dy) {\tiny  $110?0?????$}; 
  \node[] at (-\x - \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{3} \textcolor{blue}{(20.5)}$ \textcolor{red}{\bf X}}; 

%P4 right
  \node[] at (-\x + \y + 1, -2*\h   + \dy) {\tiny  $10????????$}; 
  \node[] at (-\x + \y + 1, -2*\h  -\d + \dy) {\tiny  $X_{4} \textcolor{blue}{(18)}$}; 

%P2 right
  \node[] at (\x  + 1.2, -1*\h   + \dy) {\tiny  $0?????????$}; 
  \node[] at (\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{2} \textcolor{blue}{(18.5)}$}; 

%P1 right
  \node[] at (-\x  + 1.2, -1*\h   + \dy) {\tiny  $1?????????$}; 
  \node[] at (-\x  + 1.2, -1*\h  -\d + \dy) {\tiny  $X_{1} \textcolor{blue}{(17.5)}$}; 

%P0 right
  \node[] at ( + 1.4, 0  + \dy ) {\tiny  $X=??????????$}; 
  \node[] at ( + 1.9,   -\d + \dy) {\tiny  $X_0 \textcolor{blue}{(17.5)}$}; 

%P6 below
  \node[] at (-\x + \y +\z, -3*\h - \d + \dy ) {\tiny  $100?1?????$}; 
  \node[] at (-\x + \y +\z, -3*\h - \d -\d + \dy) {\tiny  $X_{6} \textcolor{blue}{(23)}$ \textcolor{red}{\bf X}}; 

%P5 left
  \node[] at (-\x + \y -\z - 1, -3*\h  + \dy ) {\tiny  $101?0?????$}; 
  \node[] at (-\x + \y -\z - 1, -3*\h  -\d + \dy) {\tiny  $X_{5} \textcolor{blue}{(18)}$}; 

    
   \end{tikzpicture}
   \caption{\fangsong 算法{\sc IntelligentEnumerationForTSP}迭代执行7轮后产生的部分解树。$A=\{\}$，$best\_so\_far=19$。}
   \label{Step7}
\end{figure}


 \subsubsection{可行解的另一种向量表达形式：以顶点为分量}
  除了将环游表示成以边为分量的向量之外，我们还可以将可行解表示成以顶点为分量的向量。比如对于如图\ref{TSPSolutionForm}所示实例来说，环游$a\rightarrow b \rightarrow c \rightarrow d \rightarrow e  \rightarrow a$可以表示为向量$X=abcde$。上述观察可以推广到任意实例，即环游可以表示为：
  \[
  	X=x_{1}x_{2}\cdots x_{n-2},\quad x_{i} \in V\quad (1\leq i \leq n-2)
  \]
  
   类似于上一小节所做的处理，在将可行解表示成向量形式之后，我们可以采用“智能枚举”算法构造部分解树，并最终获得最优解。如图\ref{AnotherIntelligent}所示，“智能枚举”算法使用了一棵仅包含15个结点的部分解树，即求出最优解$X_{14}=adeb$，其对应的环游里程为19。
   
\begin{figure}\centering
\begin{tikzpicture}[scale=1, auto,swap]

%    \def\dx{0};
%   \def\dy{0.9} 
%    \foreach \pos/ \name in {{(-1.8+\dx,0+\dy)/a},{(1.8+\dx,0+\dy)/b}, {(-0.9+\dx,1.3+\dy)/e}, {(0.9+\dx,1.3+\dy)/c}, {(0+\dx,2.6+\dy)/d}}         
%    	\node[smallvertex,fill=blue!20] (\name) at \pos{$\name$};
%     
%    % Connect vertices with edges and draw weights
%     %   \foreach \source/ \dest/\weight in {a/b/{3},   c/a/{4}, e/a/{7}, a/d/{2}, b/c/{4}, b/d/{6}, e/b/{3}, c/d/{5}, c/e/{8}, d/e/{6}}
%    \foreach \source/ \dest/\weight in {a/b/{e_1{:}\ 3},   a/c/{}, e/a/{e_{5}{:}\  7}, b/c/{e_{4}{:}\  4}, b/e/{}, c/d/, c/e/{e_{9}{:}\  8}, d/e/}
%        \path[undirectededge] (\source) -- node[weight] {\tiny $\weight$} (\dest);
%         
%    \draw[thick] (a)   to [out=140, in=180] node[left] {\tiny $e_{3}{:}\  2$} (d);   
%        \draw[thick] (b)   to [out=40, in=0] node[right] {\tiny $e_{6}{:}\  6$} (d);   
%        
%       \foreach \source/ \dest/\weight in {a/b/,   b/c/,  c/d/, d/e/, e/a/}
%        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%
%   \node[] at (-0.7+\dx, 0.3+\dy) {\tiny $e_{2}{:}\  4$}; 
%   \node[] at (0.7+\dx, 0.3+\dy) {\tiny $e_{7}{:}\  3$}; 
%  \node[] at (-0.9+\dx, 2.0+\dy) {\tiny $e_{10}{:}\  6$}; 
%  \node[] at (0.9+\dx, 2.0+\dy) {\tiny $e_{8}{:}\  5$}; 
 
%Tree

	\def\d{2.4}; 
	\def\e{1.5};
	\def\f{1.0};
	\def\h{1.5};

% Label
%\node[ultra thick] at (-4.4, 0.5 + \dy) {\small Partial Solution Tree}; 
%\node[blue, ultra thick] at (4, 1.5) {\small $A=\{\}$}; 
%\node[blue, ultra thick] at (4, 1.0) {\small $best\_so\_far=19$}; 
	
   \node at ( -1.5*\d - 2*\e, -\h * 0.5)  {\tiny $x_2=b/c/d/e$};  
   \node at (-1.5*\d - 2*\e, -\h * 1.5)  {\tiny $x_3=b/c/d/e$};  
   \node at (-1.5*\d - 2*\e, -\h * 2.5)  {\tiny $x_4=b/c/d/e$};  
%   \node at (-1.5*\d - 2*\e, -\h * 3.5)  {\tiny $x_4=b/c/d$};  

%layer 1	
    \foreach \pos/\name/\label in {{(0,0)/root/}} 
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};
%layer 2	
    \foreach \pos/\name/\label in { {(-1.5*\d, -1*\h)/L11/}, {(-0.5*\d,-1*\h)/L12/},{(0.5*\d, -1*\h)/L13/}, {(1.5*\d, -1*\h)/L14/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	
%layer 3	
    \foreach \pos/\name/\label in { {(-1.5*\d - \e, -2*\h)/L21/}, {(-1.5*\d,  -2*\h)/L22/},{(-1.5*\d + \e, -2*\h)/L23/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	

    \foreach \pos/\name/\label in { {(0.5*\d - \e, -2*\h)/L24/}, {(0.5*\d,  -2*\h)/L25/},{(0.5*\d + \e, -2*\h)/L26/}}  
        \node[tinyvertex,draw=black, fill=white!20] (\name) at \pos {};	

%layer 4	
    \foreach \pos/\name/\label in { {(-1.5*\d + \e - \f, -3*\h)/L31/}, {(-1.5*\d + \e + \f,  -3*\h)/L32/}}  
        \node[tinyvertex,draw=black, fill=red] (\name) at \pos {};	

    \foreach \pos/\name/\label in { {(0.5*\d + \e - \f, -3*\h)/L33/}, {(0.5*\d + \e + \f,  -3*\h)/L34/}}  
        \node[tinyvertex,draw=black, fill=red] (\name) at \pos {};	

            
 % Edges 
 	%layer 1
  	\foreach \source/ \dest /\weight in {root/L11/, root/L12/, root/L13/, root/L14/ }         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	%layer 2
	 \foreach \source/ \dest /\weight in {L11/L21/, L11/L22/, L11/L23/}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	 \foreach \source/ \dest /\weight in {L13/L24/, L13/L25/, L13/L26/}         
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

	%layer 3
	 \foreach \source/ \dest /\weight in {L23/L31/, L23/L32/}
		\path[undirectededge] (\source) -- node[weight] { } (\dest);
	 \foreach \source/ \dest /\weight in {L26/L33/, L26/L34/}
		\path[undirectededge] (\source) -- node[weight] { } (\dest);

   %Label
   \def\s{1.05};  
   \def\t{0.3};  
   \node[] at (0 + \s, 0) {\tiny $X=a$???}; 
   \node[] at (0 + \s, 0 - \t) {\tiny ${\tiny X_0}$ \textcolor{blue}{(17.5)} }; 
 
  %layer 1
    \def\s{0.75};  
   \node[] at (-1.5*\d + \s, -1*\h ) {\tiny $ab$??}; 
   \node[] at (-1.5*\d + \s, -1*\h  - \t) {\tiny ${\tiny X_{1}}$ \textcolor{blue}{(17.5)} }; 

   \node[] at (-0.5*\d + \s, -1*\h ) {\tiny $ac$??}; 
   \node[] at (-0.5*\d + \s, -1*\h  - \t) {\tiny ${\tiny X_{2}}$ \textcolor{red}{\bf X} }; 
  
   \node[] at (0.5*\d + \s, -1*\h ) {\tiny $ad$??}; 
   \node[] at (0.5*\d + \s, -1*\h  - \t) {\tiny ${\tiny X_{3}}$ \textcolor{blue}{(17.5)} }; 

   \node[] at (1.5*\d + \s, -1*\h ) {\tiny $ae$?? \textcolor{red}{\bf X} }; 
   \node[] at (1.5*\d + \s, -1*\h  - \t) {\tiny ${\tiny X_{4}}$ \textcolor{blue}{(20)} }; 

%layer 2
   \node[] at (-1.5*\d -\e + \s, -2*\h ) {\tiny $abc$? \textcolor{red}{\bf X} }; 
   \node[] at (-1.5*\d -\e + \s, -2*\h  - \t) {\tiny ${\tiny X_{5}}$ \textcolor{blue}{(18.5)} }; 

   \node[] at (-1.5*\d  + \s, -2*\h ) {\tiny $abd$? \textcolor{red}{\bf X} }; 
   \node[] at (-1.5*\d  + \s, -2*\h  - \t) {\tiny ${\tiny X_{6}}$ \textcolor{blue}{(19.5)} }; 

   \node[] at (-1.5*\d +\e + \s, -2*\h ) {\tiny $abe$?}; 
   \node[] at (-1.5*\d +\e + \s, -2*\h  - \t) {\tiny ${\tiny X_{7}}$ \textcolor{blue}{(17.5)} }; 

   \node[] at (0.5*\d -\e + \s, -2*\h ) {\tiny $adc$? \textcolor{red}{\bf X} }; 
   \node[] at (0.5*\d -\e + \s, -2*\h  - \t) {\tiny ${\tiny X_{10}}$ }; 

   \node[] at (0.5*\d  + \s, -2*\h ) {\tiny $adb$? \textcolor{red}{\bf X} }; 
   \node[] at (0.5*\d  + \s, -2*\h  - \t) {\tiny ${\tiny X_{11}}$ \textcolor{blue}{(19.5)} }; 

   \node[] at (0.5*\d +\e + \s, -2*\h ) {\tiny $ade$?}; 
   \node[] at (0.5*\d +\e + \s, -2*\h  - \t) {\tiny ${\tiny X_{12}}$ \textcolor{blue}{(18)} }; 

%layer 3
   \node[] at (-1.5*\d + \e - \f + \s, -3*\h ) {\tiny $abec$}; 
   \node[] at (-1.5*\d + \e - \f  + \s, -3*\h  - \t) {\tiny ${\tiny X_{8}}$ \textcolor{blue}{(21)} }; 

   \node[] at (-1.5*\d + \e + \f + \s, -3*\h ) {\tiny $abed$}; 
   \node[] at (-1.5*\d + \e + \f  + \s, -3*\h  - \t) {\tiny ${\tiny X_{9}}$ \textcolor{blue}{(21)} }; 

   \node[] at (0.5*\d + \e - \f + \s, -3*\h ) {\tiny $adec$}; 
   \node[] at (0.5*\d + \e - \f  + \s, -3*\h  - \t) {\tiny ${\tiny X_{13}}$ \textcolor{red}{\bf X} }; 

   \node[] at (0.5*\d + \e + \f + \s, -3*\h ) {\tiny $adeb$}; 
   \node[] at (0.5*\d + \e + \f  + \s, -3*\h  - \t) {\tiny ${\tiny X_{14}}$ \textcolor{blue}{(19)} }; 

   
   \end{tikzpicture}
   \caption{\fangsong 算法{\sc IntelligentEnumerationAlgoForTSP}迭代执行6轮后产生的部分解树。$A=\{\}$，$best\_so\_far=19$。这里我们在$x_{2}=ac??$处进行剪枝的原因是仅考虑$b$出现在$c$之前的环游，以避免重复。} 
   \label{AnotherIntelligent}
\end{figure}

	
\section{算法复杂度分析}
	好的算法不仅是正确的，还应该是高效的。算法的效率可以从两个方面进行定量刻画：计算机运行算法求解问题时所需要的\uwave{运行时间长短}、以及\uwave{占用存储单元的多少}。
	
	  我们采用计时技术可以很容易地获得算法运行时间的精确数值，得到“对特定的实例，算法运行了多少秒”这样的详细信息。然而这种精确运行时间不仅与算法的优劣相关，还受实现算法所用的编程语言、CPU性能、操作系统使用的缓冲策略等多种因素影响，导致在一台计算机得到的结论无法推广到另一台计算机上去。
	  
	  为单纯地评价算法的优劣，我们脱离开运行所使用的计算机以及算法的实现等细节，只考虑算法执行过程中的\uwave{基本操作的次数}。我们假定所有的基本操作的用时都是1个时间单位，因此基本操作的次数就可以用来代表算法的运行时间（这个假定的合理性，我们将在第9章讲述）。至于哪些操作是基本操作，则是依赖于具体问题的，需要针对具体问题做具体的约定。在不做特殊声明时，我们假定如下操作是基本操作：两个整数的加、减、乘、除以及比较大小；判断两个整数是否相等；逻辑运算“{\sc AND}”、“{\sc OR}”和“{\sc NOT}”；变量的赋值、读和写。
	
	
	下面我们从一个简单的例子---计算Fibonacci数---谈起。
		Fibonacci数列是指这样的一列数：
\[
	0, 1, 1, 2, 3, 5, 8, 13, 21, ...... 
\]	
其中前两项是0和1，后续项是其两个直接前项之和。Fibonacci数列可以用递归的方式定义：
\[
	F_{n} = \begin{cases} 
				0 & \text{ if } n = 0 \nonumber \\ 
				1  & \text{ if } n = 1 \nonumber \\
				F_{n-1} + F_{n-2} & \text{otherwise} \nonumber
			\end{cases}
\]
	我们考虑如下问题：给定$n$，计算Fibonacci数列中的第$n$项$F_{n}$。形式化描述为：
\begin{center}
	\fbox{
		\begin{minipage}{30em}
{\bf Fibonacci数计算问题}\\
	{\bf 输入：}  自然数$n\geq 0$；\\
	{\bf 输出：} Fibonacci数 $F_n$。
		\end{minipage}
	}
\end{center}
	
	
	一种简单的思路是直接按照定义写成递归程序，描述如下：
\begin{algorithm}[H]
\caption{Calculation of Fibonacci number}\label{Fibonacci1}
{\bf function} {\sc F}{$(n)$} 
\begin{algorithmic}[1]
	\REQUIRE{$n\geq 0$}
	\IF{$n == 0$}
		\RETURN{$0$;}
	\ELSIF{$n==1$}
		\RETURN{$1$;}
	\ELSE
		\RETURN{{\sc F}$({n-1})+${\sc F}$({n-2})$;}
	\ENDIF
\end{algorithmic}
\end{algorithm}	
这个算法是对递归定义的忠实翻译，其正确性是毋庸置疑的。但是算法的效率却不是显而易见的。我们考虑计算$F_{n}$所需的\uwave{基本操作次数}，记为$T(n)$。这里所谓的基本操作包括判断两个数是否相等（第1行、第4行）、两个数相加（第7行）。我们能够观察到如下两点：
\begin{enumerate}[(1)]
	\item 当$n\leq 1$时，上述算法执行最多两次基本操作，即：
\[
	T(n) \leq 2,  \quad \text{当} n \leq 1\text{时}
\]	
	\item 当$n>1$是，上述算法需要执行两次递归调用，再加上3次基本操作，从而有：
\[
	T(n) = T(n-1)+T(n-2) + 3,  \quad \text{当} n > 1\text{时}
\]	
\end{enumerate}
很容易能够证明：$T(n) \geq F_{n}$。这意味着基本操作次数$T(n)$随着$n$成指数式增长，比如当$n=20$时，$T(n)\geq 6765$；当$n=30$时，$T(n)\geq 832040$；当$n=40$时，$T(n)\geq 102334155$；当$n=50$时，$T(n)\geq 12586269025$。因此，除了$n$取非常小的数值之外，上述算法都会非常慢。

只需检查一个简单的例子就能够清楚看出，导致算法低效的原因在于重复计算。图\ref{F5}展示了计算$F(5)$的递归调用过程，其中$F(3)$被重复计算2次，$F(2)$被重复计算3次。当$n$取更大的数值时，计算$F(n)$时的重复计算就更多了。

\begin{figure}[H]\centering

\begin{tikzpicture}[scale=1., auto,swap]
    % Draw a 7,11 network
    % First we draw the vertices
    \foreach \pos/\name/\label in {{(0,0)/root/F(5)}, 
    {(-3,-1)/L/F(3)}, {(3,-1)/R/F(4)}, 
    {(-4.5,-2)/LL/F(1)}, {(-1.5, -2)/LR/F(2)}, {(1.5, -2)/RL/F(2)}, {(4.5, -2)/RR/F(3)}, 
    {(-2.2, -3)/LRL/F(0)}, {(-0.8, -3)/LRR/F(1)},
    {(5.2, -3)/RRR/F(2)}, {(3.8, -3)/RRL/F(1)},{(2.2, -3)/RLR/F(1)}, {(0.8, -3)/RLL/F(0)},
    {(5.2-0.5, -4)/RRRL/F(0)}, {(5.2+0.5, -4)/RRRR/F(1)}}
        \node[vertex,draw=black, fill=blue!20] (\name) at \pos {\small $\label$};
  
    % Connect vertices with edges and draw weights
  \foreach \source/ \dest /\weight in {root/L/{}, root/R/{}, L/LL/{}, L/LR/{}, R/RL/{}, R/RR/{},LR/LRL/{},LR/LRR/{}, RL/RLL/{}, RL/RLR/{}, RR/RRL/{}, RR/RRR/{}, RRR/RRRR/{}, RRR/RRRL/{}}
        \path[undirectededge] (\source) -- node[weight] {$\weight$} (\dest);
%       \draw[dashed, ->] (0,0) arc  (120:60:2);
 
   \end{tikzpicture}
   \caption{\fangsong $F(5)$的递归计算过程。}
   \label{F5}
\end{figure}

为避免重复计算，一种简单而有效的策略是将已经计算过的数值$F_k$存入一个表格中，以后再次计算$F_k$时直接查表即可。采用这种策略的算法描述如下：
\begin{algorithm}[H]
\caption{Calculation of Fibonacci number}\label{Fibonacci2}
{\bf function} {\sc Fibonacci}{$(n)$}
\begin{algorithmic}[1]
	\REQUIRE{$n\geq 0$} 
	\IF{$n == 0$}
		\RETURN{$0$;}
	\ELSIF{$n==1$}
		\RETURN{$1$;}	
	\ENDIF
	\STATE{Allocate an array $f[0..n]$;}
	\STATE{$f[0] = 0; $}
	\STATE{$f[1] = 1; $}
	\FOR{$i = 2$ to $n$}
		\STATE{$f[i] = f[i-1]+f[i-2]$;}
	\ENDFOR
	\RETURN{$f[n]$;}
\end{algorithmic}
\end{algorithm}	
很明显可以看出，当$n\geq 2$时，这个新的算法的基本操作次数$T(n)=n+5$，随$n$成线性增长。因此，我们可以说第二个算法比第一个算法更高效。

\subsection{时间复杂度与空间复杂度}
 	在约定了算法的基本操作之后，算法执行过程中的\uwave{总的基本操作次数}称为算法的\uwave{时间复杂度}，算法所使用的存储器单元数目则称为算法的\uwave{空间复杂度}。我们很容易观察到时间和空间复杂度受两方面因素的影响：
	\begin{enumerate}[(1)] 
		\item 无论是时间复杂度还是空间复杂度，都和实例的规模密切相关：对规模较大的实例，通常需要较多的基本操作次数以及存储单元数目。在计算Fibonacci数$F_n$时，我们使用$n$来表示问题实例的规模；而对于旅行商问题而言，我们常常使用结点数目来表示实例的规模（问题规模的精确定义涉及到实例的编码方式，是指在特定的编码方式下实例的编码长度，称为“输入长度”。我们将在第9章做详细描述）。
		\item 即使在规模相同的条件下，对于不同的实例，算法的时间复杂度和空间复杂度往往也会不同。以旅行商问题为例，当限定结点数$n=5$时，如果结点间距离不同，“智能枚举”算法的运行时间一般也会不同。
	\end{enumerate}	
	
        仅凭算法在一个或少数几个特定实例上的时间和空间复杂度，难以准确评估其性能。因此，常用的方式是考虑具有同等规模的所有实例，以在所有实例上基本操作次数的最大值作为时间复杂度，称为“\uwave{最坏情况时间复杂度}”（Worst-case time complexity)；以在所有实例上使用存储单元数目的最大值作为空间复杂度，称为“\uwave{最坏情况空间复杂度}”（Worst-case space complexity)。由于忽略了具体实例的影响，时间复杂度和空间复杂度只与实例规模相关，可以表示成\uwave{实例规模的函数}。以上一小节中的两个算法为例，第一个算法的时间复杂度$T(n)\geq F(n)$，第二个算法的时间复杂度为$T(n) = n+5$。	图\ref{TimeComplexity}展示了常见的时间复杂度函数及其之间的关系。

        
       除了最大值之外，还有另外一种方式考虑算法在具有同等规模的所有实例上的表现：以在所有实例上基本操作次数的平均值作为时间复杂度，称为“\uwave{平均情况时间复杂度}”（Average-case time complexity）；以在所有实例上存储单元数目的平均值作为空间复杂度，称为“\uwave{平均情况空间复杂度}”（Average-case space complexity)。然而平均值的计算，需要事先已知问题实例的概率分布，从而导致这一方案很难行得通。因此在讨论时间和空间复杂度是，常常是指最坏情况时间和空间复杂度。
        
        	\begin{figure}[hpt]\centering
		\centering
        	\includegraphics[width=2.5in]{Time-complexity.png}
		\caption{\fangsong 常见的复杂度函数及其之间的关系。}
    \end{figure}
        
 
%    这里我们使用$n$来表示问题实例的规模；而对于旅行商问题而言，我们常常使用结点数目来表示实例的规模。一般来讲，一个算法解答一个规模为$n$的实例，其时间复杂度函数$T(n)$和空间复杂度函数$S(n)$都会随$n$的增加而增加，但往往又不是$n$的严格单调函数。
    
\subsection{大$O$记号}
	当我们想比较两个算法的复杂度，或者想简化一个算法复杂度的表示时，我们可以使用“大$O$符号”。比如上面描述的计算Fibonacci数的两个算法，第一个算法的时间复杂度为$T_1(n) \geq F_n$，第二个算法的时间复杂度为$T_2(n) = n + 5$，我们说$T_2(n) = O( T_1(n) )$，其直观含义是“第二个算法时间复杂度增加速度更慢，性能更好”。大$O$符号的精确定义描述如下：
\begin{definition}[大$O$记号]
	考虑两个函数$f(n)$和$g(n)$，其定义域是正整数，值域是正实数。如果存在一个正数$c >0$以及$N > 0$，使得对任意的$n > N$，总有$f(n) \leq c g(n)$成立，则记为$f(n) = O(g(n))$。
\end{definition}
	大$O$符号的含义类似于 “$\leq$”，只是附加了两个限制：
	\begin{enumerate}[(1)]
		\item  不是简单地指$f(n)$小于等于$g(n)$，而是$f(n)$小于等于$g(n)$的某个常数倍；因此可以把大$O$符号看做一个“隐含的常数”\cite{SipserBook}。比如对$f(n) = 10 n$，$g(n) = n$，虽然$10 n > n$，但是我们能推导出$10 n  = O(n)$。这使得我们可以忽略系数，只关注复杂度中的主要部分。
		\item 不等式只需要对充分大的$n$成立即可（也称为“渐进估计”）。比如$f(n) = 10 n $，$g(n) = n^2$，当$n \leq 10$时，$10 n > n^2$；而当$n> 10$时，$10 n \leq  n^2$。之所以只关注$n$充分大的情况，其原因在于：当实例规模$n$很小时，算法一般都比较快，不同算法之间性能差异一般不太大，因此我们更关心当$n$增大时，复杂度的增长趋势的差异。
	\end{enumerate}	
	如同大$O$符号的含义类似于 “$\leq$”，我们还可以使用类似于“$\geq$”的符号$\Omega$，以及类似于“$=$”的符号$\Theta$ \cite{Knuth1976}：
\begin{definition}[$\Omega$记号和$\Theta$记号]
	考虑两个函数$f(n)$和$g(n)$，其定义域是正整数，值域是正实数。如果$f(n) = O(g(n))$，则可以记为$g(n) = \Omega( f(n))$。如果$f(n) = O(g(n))$和$g(n) = O(f(n))$同时成立，则可以记为$f(n) = \Theta(g(n))$。
\end{definition}
	

	下面我们先来看如何使用上述符号，比较不同算法的时间和空间复杂度。我们以下述三个算法的时间复杂度为例：
	\begin{eqnarray}
T_1(n) =& 100 n^2 + n + 1  \nonumber \\
 	T_2(n) =& n^2  \nonumber\\
 	T_3(n) =& n^3  \nonumber
	\end{eqnarray}
我们能够得到如下结论： 
	\begin{enumerate}[(1)]
		\item   $T_2(n) = O(T_1(n))$，表示算法2比算法1优越，但是其优越性只体现在常数倍的差异上；和$T_1(n)$和$T_3(n)$之间的差异比较而言，$T_1(n)$与$T_2(n)$之间的差异微不足道。  
		\item   我们同时还能推出$T_1(n) = O(T_2(n))$，从而表示当忽略常数系数之后，$T_1(n)$和$T_2(n)$具有相同的增长趋势，即$T_1(n) = \Theta(T_2(n))$。
		\item  $T_1(n) = O(T_3(n) )$，表示算法1比算法3更高效。
	\end{enumerate}	

	接着我们来看如何使用大$O$符号来简化时间和空间复杂度的表达，获得复杂度的上界。我们可以使用如下的经验规则：
	\begin{enumerate}[(1)]
		\item 如果复杂度函数可以写成多项之和，我们可以只保留占支配地位的那一项。比如$ 100 n^2 + n + 1 = O(100 n^2)$， 其原因在于：当$n$比较大时，低次项$n$和$1$相对于高次项$100n^2$来说很小，去除之后影响不大。类似地，我们有$2^n + n^{100} = O(2^n)$，其原因在于：和$n^{100}$相比而言，$2^n$占支配地位；此外，$n^{0.01} + \log n = O(n^{0.01})$，其原因在于：和$ \log n$相比而言，$n^{0.01}$占支配地位。
		\item 复杂度函数里占支配地位那一项的系数可以忽略，例如$ 100 n^2 + n + 1 = O( n^2)$。
	\end{enumerate}	
	在对复杂度函数进行简化之后，我们常常能够获得形如$O(n^c)$的上界，其中$c$是大于0的常数，这种界称作\uwave{多项式界}；形如$O(2^{(n^c)}$的上界称作\uwave{指数界}。

\section*{延伸阅读}
1999年，Steven S. Skiena做了一项关于算法需求的“市场调研”\cite{Skiena1999}。他首先建立了Stony Brook算法库(http://www.cs.sunysb.edu/$\sim$algorith)，涵盖7大类、75个问题的求解算法及实现；然后他分析了访问记录，以了解访问者对哪些算法更感兴趣。统计数据表明：最短路径算法的访问量最多，旅行商问题的求解算法的访问量也很多，位列第4名。
	
	
	
\section*{习题}	
\begin{enumerate}[1.]
	\item 比较如下的复杂度函数$f(n)$和$g(n)$，使用大$O$符号、$\Omega$记号或者$\Theta$记号表示$f(n)$和$g(n)$之间的关系：
	\begin{enumerate}[(1)]
		\item $f(n) = 2n^ 3 + 3 n $, $g(n) = 100 n^2 + 2n$ 
		\item $f(n) = n \log n  $, $g(n) = n^2 $ 
		\item $f(n) =  \log n  $, $g(n) = (\log n)^2 $ 
		\item $f(n) =  \log n ^{2 \log n }  $, $g(n) = n^2 $ 
		\item $f(n) = n \log n  $, $g(n) = n^2 $ 
		\item $f(n) = n!  $, $g(n) = 2^n $ 
		\item $f(n) = \log n   $, $g(n) =  \log\log n  $ 
		\item $f(n) = n^{0.01}  $, $g(n) =  \log^2 n $ 
		\item $f(n) = n 2^n  $, $g(n) = 3^n $ 
	\end{enumerate}	
	
	\item 考虑求解最大公约数问题（Greatest Common Divisor, GCD）：
\begin{center}
	\fbox{
		\begin{minipage}{30em}
{\bf 最大公约数计算问题}\\
	{\bf 输入：}  两个整数$a$和$b$，$a \geq  b  \geq 0$；\\
	{\bf 输出：} $a$和$b$的最大公约数$gcd(a, b)$。
		\end{minipage}
	}
\end{center}
	采用Euclid的辗转相除法，我们可以设计如下的求解算法：	
\begin{algorithm}[H]
\caption{Calculation of Greatest Common Divisor}\label{GCD}
{\bf function} {\sc Euclid}$(a,b)$
\begin{algorithmic}[1]
\REQUIRE{$a \geq  b  \geq 0$} 
\IF{$b = 0$}  
	\RETURN $a$; 
\ENDIF
\RETURN{{\sc Euclid}$(b, a\mod b)$}; 
\end{algorithmic}
\end{algorithm}
	试证明算法{\sc Euclid}的时间复杂度是$O(n^3)$，此处$n$表示$a$的二进制表示中的比特数。算法的基本操作包括：检测一个数是否等于$0$、一个比特位上的加法和减法。

	\item 考虑如下的多项式求值问题：
\begin{center}
	\fbox{
		\begin{minipage}{30em}
{\bf 多项式求值问题}\\
	{\bf 输入：}  多项式系数$a_0, a_1, \cdots, a_n$，实数$x$；\\
	{\bf 输出：} 多项式$a_n x^n + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0$的值。
		\end{minipage}
	}
\end{center}
	试设计多项式求值算法，时间复杂度分别为: $(i)$ $\Omega(n^2)$； $(ii)$ $O(n)$。这里的基本操作包括：实数的加法和乘法。

\end{enumerate}	
		
